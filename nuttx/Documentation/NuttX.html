<html>
<head>
<title>NuttX</title>
</head>
<body background="backgd.gif">
<hr><hr>
<table width ="100%">
  <tr align="center" bgcolor="#e4e4e4">
    <td>
      <h1><big><font color="#3c34ec"><i>NuttX RTOS</i></font></big></h1>
      <p>Last Updated: April 17, 2013</p>
    </td>
  </tr>
</table>
<hr><hr>
<table width ="100%">
  <tr bgcolor="#e4e4e4">
    <td>
  <h1>Table of Contents</h1>
    </td>
  </tr>
</table>

<center><table width ="80%">
<tr>
<td>
<table>
<tr>
  <td valign="top" width="22"><img height="20" width="20" src="favicon.ico"></td>
  <td>
    <a href="#overview">Overview</a>.<br>
    What is NuttX?  Look at all those files and features... How can it be a tiny OS?
  </td>
</tr>
<tr>
  <td valign="top" width="22"><img height="20" width="20" src="favicon.ico"></td>
  <td>
    <a href="#group">NuttX Discussion Group</a>.<br>
    Do you want to talk about NuttX features?  Do you need some help?  Problems?  Bugs?
  </td>
</tr>
<tr>
  <td valign="top" width="22"><img height="20" width="20" src="favicon.ico"></td>
  <td>
    <a href="#downloads">Downloads</a>.<br>
    Where can I get NuttX?  What is the current development status?
  </td>
</tr>
<tr>
  <td valign="top" width="22"><img height="20" width="20" src="favicon.ico"></td>
  <td>
    <a href="#platforms">Supported Platforms</a>.<br>
    What target platforms has NuttX been ported to?
  </td>
</tr>
<tr>
  <td valign="top" width="22"><img height="20" width="20" src="favicon.ico"></td>
  <td>
    <a href="#environments">Development Environments</a>.<br>
    What kinds of host cross-development platforms can be used with NuttX?
  </td>
</tr>
<tr>
  <td valign="top" width="22"><img height="20" width="20" src="favicon.ico"></td>
  <td>
    <a href="#footprint">Memory Footprint</a>.<br>
    Just how big is it?  Do I have enough memory to use NuttX?
  </td>
</tr>
<tr>
  <td valign="top" width="22"><img height="20" width="20" src="favicon.ico"></td>
  <td>
    <a href="#licensing">Licensing</a>.<br>
    Are there any licensing restrictions for the use of NuttX? (Almost none)
    Will there be problems if I link my proprietary code with NuttX? (No)
  </td>
</tr>
<tr>
  <td valign="top" width="22"><img height="20" width="20" src="favicon.ico"></td>
  <td>
    <a href="#history">Release History</a><br>
    What has changed in the last release of NuttX?
    What unreleased changes are pending in GIT?
  </td>
</tr>
<tr>
  <td valign="top" width="22"><img height="20" width="20" src="favicon.ico"></td>
  <td>
    <a href="#TODO">Bugs, Issues, <i>Things-To-Do</i></a>.<br>
    Software is never finished nor ever tested well enough.
    (Do you want to help develop NuttX?  If so, send me an email).
  </td>
</tr>
<tr>
  <td valign="top" width="22"><img height="20" width="20" src="favicon.ico"></td>
  <td>
    <a href="#documentation">Other Documentation</a>.<br>
    What other NuttX documentation is available?
  </td>
</tr>
<tr>
  <td valign="top" width="22"><img height="20" width="20" src="favicon.ico"></td>
  <td>
    <a href="#trademarks">Trademarks</a>.<br>
    Some of the words used in this document belong to other people.
  </td>
</tr>
</table>
</td>
</tr>
</table></center>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="overview"><h1>Overview</h1></a>
  </td>
  </tr>
</table>

<p>
  <b>Goals</b>.
  NuttX is a real timed embedded operating system (RTOS).
  Its goals are:
<p>
<center><table width="90%">
<tr>
  <td valign="top" width="22"><img height="20" width="20" src="favicon.ico"></td>
  <td bgcolor="#5eaee1">
    <b>Small Footprint</b>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      Usable in all but the tightest micro-controller environments,
      The focus is on the tiny-to-small, deeply embedded environment.
    </p>
</tr>
<tr>
  <td valign="top" width="22"><img height="20" width="20" src="favicon.ico"></td>
  <td bgcolor="#5eaee1">
    <b>Rich Feature OS Set</b>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      The goal is to provide implementations of most standard POSIX OS interfaces
      to support a rich, multi-threaded development environment for deeply embedded
      processors.
    </p>
      NON-GOALS: (1) It is not a goal to provide the level of OS features like those provided by Linux.
      In order to work with smaller MCUs, small footprint must be more important than an extensive feature set.
      But standard compliance is more important than small footprint.
      Surely a smaller RTOS could be produced by ignoring standards.
      Think of NuttX is a tiny Linux work-alike with a much reduced feature set.
      (2) There is no MMU-based support for processes.
      At present, NuttX assumes a flat address space.
    </p>
</tr>
<tr>
  <td valign="top" width="22"><img height="20" width="20" src="favicon.ico"></td>
  <td bgcolor="#5eaee1">
    <b>Highly Scalable</b>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      Fully scalable from tiny (8-bit) to moderate embedded (32-bit).
      Scalability with rich feature set is accomplished with:
      Many tiny source files, link from static libraries, highly configurable, use of
      weak symbols when available.
    </p>
</tr>
<tr>
  <td valign="top" width="22"><img height="20" width="20" src="favicon.ico"></td>
  <td bgcolor="#5eaee1">
    <b>Standards Compliance</b>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      NuttX strives to achieve a high degree of standards compliance.
      The primary governing standards are POSIX and ANSI standards.
      Additional standard APIs from Unix and other common RTOS's are
      adopted for functionality not available under these standards
      or for functionality that is not appropriate for the deeply-embedded
      RTOS (such as <code>fork()</code>).
    </p>
    <p>
      Because of this standards conformance, software developed under other
      standard OSs (such as Linux) should port easily to NuttX.
    </p>
</tr>
<tr>
  <td valign="top" width="22"><img height="20" width="20" src="favicon.ico"></td>
  <td bgcolor="#5eaee1">
    <b>Real-Time</b>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      Fully pre-emptible, fixed priority and round-robin scheduling.
    </p>
</tr>
<tr>
  <td valign="top" width="22"><img height="20" width="20" src="favicon.ico"></td>
  <td bgcolor="#5eaee1">
    <b>Totally Open</b>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      Non-restrictive BSD license.
    </p>
</tr>
<tr>
  <td valign="top" width="22"><img height="20" width="20" src="favicon.ico"></td>
  <td bgcolor="#5eaee1">
    <b>GNU Toolchains</b>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      Compatible GNU toolchains based on <a href="http://buildroot.uclibc.org/">buildroot</a>
      available for
      <a href="https://sourceforge.net/projects/nuttx/files/">download</a>
      to provide a complete development environment for many architectures.
    </p>
</tr>
</table></center>

<p>
  <b>Feature Set</b>.
  Key features of NuttX include:
<p>
<center><table width="90%">

<tr>
  <td valign="top" width="22"><img height="20" width="20" src="favicon.ico"></td>
  <td bgcolor="#5eaee1">
    <b>Standards Compliant Core Task Management</b>
  </td>
</tr>

<tr>
  <td><br></td>
  <td>
    <p>
      <li>Fully pre-emptible.</li>
    </p>
</tr>

<tr>
  <td><br></td>
  <td>
    <p>
      <li>Naturally scalable.</li>
    </p>
</tr>

<tr>
  <td><br></td>
  <td>
    <p>
      <li>Highly configurable.</li>
    </p>
</tr>

<tr>
  <td><br></td>
  <td>
    <p>
      <li>
        Easily extensible to new processor architectures, SoC architecture, or board architectures.
        A <a href="NuttxPortingGuide.html">Porting Guide</a> is available.
      </li>
    </p>
</tr>

<tr>
  <td><br></td>
  <td>
    <p>
      <li>FIFO and round-robin scheduling.</li>
    </p>
</tr>

<tr>
  <td><br></td>
  <td>
    <p>
      <li>Realtime, deterministic, with support for priority inheritance</li>
    </p>
</tr>

<tr>
  <td><br></td>
  <td>
    <p>
      <li>POSIX/ANSI-like task controls, named message queues, counting semaphores, clocks/timers, signals, pthreads, environment variables, filesystem.</li>
    </p>
</tr>

<tr>
  <td><br></td>
  <td>
    <p>
      <li>VxWorks-like task management and watchdog timers.</li>
    </p>
</tr>

<tr>
  <td><br></td>
  <td>
    <p>
      <li>BSD socket interface.</li>
    </p>
</tr>

<tr>
  <td><br></td>
  <td>
    <p>
      <li>Extensions to manage pre-emption.</li>
    </p>
</tr>

<tr>
  <td><br></td>
  <td>
    <p>
      <li>Optional tasks with address environments (<i>Processes</i>).</li>
    </p>
</tr>

<tr>
  <td><br></td>
  <td>
    <p>
      <li>Inheritable &quot;controlling terminals&quot; and I/O re-direction.</li>
    </p>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <li>On-demand paging.</li>
    </p>
</tr>

<tr>
  <td><br></td>
  <td>
    <li>System logging.</li>
    </p>
</tr>

<tr>
  <td><br></td>
  <td>
    <p>
      <li>May be built either as an open, flat embedded RTOS or as a separately built, secure, monolithic kernel with a system call interface.</li>
    </p>
</tr>

<tr>
  <td><br></td>
  <td>
    <p>
      <li>Well documented in the NuttX <a href="NuttxUserGuide.html">User Guide</a>.</li>
    </p>
</tr>

<tr>
  <td valign="top" width="22"><img height="20" width="20" src="favicon.ico"></td>
  <td bgcolor="#5eaee1">
    <b>File system</b>
  </td>
</tr>

<tr>
  <td><br></td>
  <td>
    <p>
      <li>Tiny, in-memory, root pseudo-file-system.</li>
    </p>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <li>Virtual file system supports drivers and mountpoints.</li>
    </p>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <li>
        Mount-able volumes.  Bind mountpoint, filesystem, and block device driver.
      </li>
    </p>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <li>Generic system logging (SYSLOG) support.</li>
    </p>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <li>
        FAT12/16/32 filesystem support with optional FAT long file name support<small><sup>1</sup></small>.
      </li>
    </p>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <li>
        NFS Client. Client side support for a Network File System (NFS, version 3, UDP).
      </li>
    </p>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <li>
        NXFFS. The tiny NuttX wear-leveling FLASH file system.
      </li>
    </p>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <li>ROMFS filesystem support.</li>
    </p>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <li>BINFS pseudo-filesystem support.</li>
    </p>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <li>
        A <a href="NuttXBinfmt.html">binary loader</a> with support for the following formats:
        <ul>
          <li>Separately linked ELF modules.</li>
          <li>
            Separately linked <a href="NuttXNxFlat.html">NXFLAT</a> modules.
            NXFLAT is a binary format that can be XIP from a file system.
          </li>
          <li>
            &quot;Built-In&quot; applications.</li>
          </li>
        </ul>
      </li>
    </p>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <li>PATH variable support.</li>
    </p>
</tr>
<tr>
  <td><br></td>
  <td>
    <p><small>
      <sup>1</sup>
      FAT long file name support may be subject to certain Microsoft patent restrictions if enabled.
      See the top-level <code>COPYING</code> file for details.
    </small></p>
</tr>

<tr>
  <td valign="top" width="22"><img height="20" width="20" src="favicon.ico"></td>
  <td bgcolor="#5eaee1">
    <b>Device Drivers</b>
  </td>
</tr>

<tr>
  <td><br></td>
  <td>
    <p>
      <li>Supports character and block drivers as well as specialized driver interfaces.</li>
    </p>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <li>
        Network, USB (host), USB (device), serial, CAN, ADC, DAC, PWM, Quadrature Encoder, and watchdog timer driver architectures.
      </li>
    </p>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <li>
        RAMDISK, pipes, FIFO, <code>/dev/null</code>, <code>/dev/zero</code>, <code>/dev/random</code>, and loop drivers.
      </li>
    </p>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <li>Generic driver for SPI-based or SDIO-based MMC/SD/SDH cards.</li>
    </p>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <li><a href="NuttxPortingGuide.html#pwrmgmt">Power management</a> sub-system.</li>
    </p>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <li>ModBus support provided by built-in <a href="http://freemodbus.berlios.de/">FreeModBus</a> version 1.5.0.</li>
    </p>
  </td>
</tr>

<tr>
  <td valign="top" width="22"><img height="20" width="20" src="favicon.ico"></td>
  <td bgcolor="#5eaee1">
    <b>C/C++ Libraries</b>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <li>Standard C Library Fully integrated into the OS.</li>
    </p>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <li>Includes floating point support via a Standard Math Library.</li>
    </p>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <li>Add-on <a href="http://cxx.uclibc.org/">uClibc++</a> module provides Standard C++ Library (LGPL).</li>
    </p>
  </td>
</tr>

<tr>
  <td valign="top" width="22"><img height="20" width="20" src="favicon.ico"></td>
  <td bgcolor="#5eaee1">
    <b>Networking</b>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <li>TCP/IP, UDP, ICMP, IGMPv2 (client) stacks.</li>
    </p>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <li>SLIP</li>
    </p>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <li>A port cJSON</li>
    </p>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <li>Small footprint (based on uIP).</li>
    </p>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <li>BSD compatible socket layer.</li>
    </p>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <li>Networking utilities (DHCP server and client, SMTP client, TELNET client, FTP server and client, TFTP client, HTTP server and client).  Inheritable TELNET sessions (as &quot;controlling terminal&quot;)</li>
    </p>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <li>
        NFS Client. Client side support for a Network File System (NFS, version 3, UDP).
      </li>
    </p>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <li>
        A NuttX port of Jeff Poskanzer's <a href="http://acme.com/software/thttpd">THTTPD</a> HTTP server
        integrated with the NuttX <a href="NuttXBinfmt.html">binary loader</a> to provide true, embedded CGI.
      </li>
    </p>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <li>
        UDP Network Discover (Contributed by Richard Cochran).
      </li>
    </p>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <li>
        XML RPC Server (Contributed by Richard Cochran).
      </li>
    </p>
  </td>
</tr>

<tr>
  <td valign="top" width="22"><img height="20" width="20" src="favicon.ico"></td>
  <td bgcolor="#5eaee1">
    <b>FLASH Support</b>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <li><i>MTD</i>-inspired interface for <i>M</i>emory <i>T</i>echnology <i>D</i>evices.</li>
    </p>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <li><i>FTL</i>.  Simple <i>F</i>lash <i>T</i>ranslation <i>L</i>ayer support file systems on FLASH.</li>
    </p>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <li>NXFFS. the NuttX wear-leveling FLASH file system.</li>
    </p>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <li>Support for SPI-based FLASH and FRAM devices.</li>
    </p>
</tr>

<tr>
  <td valign="top" width="22"><img height="20" width="20" src="favicon.ico"></td>
  <td bgcolor="#5eaee1">
    <b>USB Host Support</b>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <li>USB host architecture for USB host controller drivers and device-dependent USB class drivers.</li>
    </p>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <li>USB host controller drivers available for the NXP LPC17xx.</li>
    </p>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <li>Device-dependent USB class drivers available for USB mass storage and HID keyboard.</li>
    </p>
</tr>

<tr>
  <td valign="top" width="22"><img height="20" width="20" src="favicon.ico"></td>
  <td bgcolor="#5eaee1">
    <b>USB Device Support</b>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <li><i>Gadget</i>-like architecture for USB device controller drivers and device-dependent USB class drivers.</li>
    </p>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <li>USB device controller drivers available for the PIC32, NXP LPC17xx, LPC214x, LPC313x, LPC43xx, STMicro STM32 and TI DM320.</li>
    </p>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <li>Device-dependent USB class drivers available for USB serial (CDC/ACM and a PL2303 emulation), for USB mass storage, and for a composite CDC/ACM and mass storage device.</li>
    </p>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <li>Built-in <a href="UsbTrace.html">USB trace</a> functionality for USB debug.</li>
    </p>
</tr>

<tr>
  <td valign="top" width="22"><img height="20" width="20" src="favicon.ico"></td>
  <td bgcolor="#5eaee1">
    <b>Graphics Support</b>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <li>Framebuffer drivers.</li>
    </p>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <li>LCD drivers for both parallel and SPI LCDs and OLEDs.</li>
    </p>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <li>
         NX: A graphics library, tiny windowing system and tiny font support that works with either framebuffer or LCD drivers.
         Documented in the <a href="NXGraphicsSubsystem.html">NX Graphics Subsystem</a>
         manual.
      </li>
    </p>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <li>Font management sub-system.</li>
    </p>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <li>
         <a href="NxWidgets.html">NxWidgets</a>: NXWidgets is library of graphic objects, or &quot;widgets,&quot (labels, buttons, text boxes, images, sliders, progress bars, etc.). NXWidgets is written in C++ and integrates seamlessly with the NuttX NX graphics and font management subsystems.
      </li>
    </p>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <li>
         <a href="NxWidgets.html">NxWM</a>: NxWM is the tiny NuttX window manager based on NX and NxWidgets.
      </li>
    </p>
</tr>

<tr>
  <td valign="top" width="22"><img height="20" width="20" src="favicon.ico"></td>
  <td bgcolor="#5eaee1">
    <b>Input Devices</b>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <li>Touchscreen, USB keyboard, GPIO-based buttons and keypads. </li>
    </p>
</tr>

<tr>
  <td valign="top" width="22"><img height="20" width="20" src="favicon.ico"></td>
  <td bgcolor="#5eaee1">
    <b>Analog Devices</b>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <li>Support for Analog-to-Digital conversion (ADC), Digital-to-Analog conversion (DAC), multiplexers, and amplifiers.</li>
    </p>
</tr>

<tr>
  <td valign="top" width="22"><img height="20" width="20" src="favicon.ico"></td>
  <td bgcolor="#5eaee1">
    <b>Motor Control</b>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <li>Pulse width modulation (PWM) / Pulse count modulation.</li>
    </p>
</tr>
</table></center>

<p>
  <b>NuttX Add-Ons</b>.
  The following packages are available to extend the basic NuttX feature set:
</p>
<center><table width="90%">

<tr>
  <td valign="top" width="22"><img height="20" width="20" src="favicon.ico"></td>
  <td bgcolor="#5eaee1">
    <b>NuttShell (NSH)</b>
  </td>
</tr>

<tr>
  <td><br></td>
  <td>
    <p>
      <li>A small, scalable, bash-like shell for NuttX with rich feature set and small footprint.
        See the <a href="NuttShell.html">NuttShell User Guide</a>.</li>
    </p>
</tr>

<tr>
  <td valign="top" width="22"><img height="20" width="20" src="favicon.ico"></td>
  <td bgcolor="#5eaee1">
    <b>Pascal Compiler with NuttX runtime P-Code interpreter add-on</b>
  </td>
</tr>

<tr>
  <td><br></td>
  <td>
    <p>
      <li>The Pascal add-on is available for download from the
        <a href="http://sourceforge.net/projects/nuttx/files/">SourceForge</a>
        website.</li>
    </p>
  </td>
</tr>
</table></center>

<p>
  <b>Look at all those files and features... How can it be a tiny OS?</b>.
  The NuttX feature list (above) is fairly long and if you look at the NuttX
  source tree, you will see that there are hundreds of source files comprising
  NuttX.  How can NuttX be a tiny OS with all of that?
</p>
<center><table width="90%">

<tr>
  <td valign="top" width="22"><img height="20" width="20" src="favicon.ico"></td>
  <td bgcolor="#5eaee1">
    <b>Lots of Features -- More can be smaller!</b>
  </td>
</tr>

<tr>
  <td><br></td>
  <td>
    <p>
      The philosophy behind that NuttX is that lots of features are great... <i>BUT</i>
      also that if you don't use those features, then you should not have to pay a penalty
      for the unused features.
      And, with NuttX, you don't!  If you don't use a feature, it will not
      be included in the final executable binary.
      You only have to pay the penalty of increased footprint for the features
      that you actually use.
    </p>
    <p>
      Using a variety of technologies, NuttX can scale from the very tiny to
      the moderate-size system.  I have executed NuttX with some simple applications
      in as little as 32K <i>total</i> memory (code and data).
      On the other hand, typical, richly featured NuttX builds require more like 64K
      (and if all of the features are used, this can push 100K).
    </p>
  </td>
</tr>

<tr>
  <td valign="top" width="22"><img height="20" width="20" src="favicon.ico"></td>
  <td bgcolor="#5eaee1">
    <b>Many, many files -- More really is smaller!</b>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      One may be intimidated by the size NuttX source tree.  There are hundreds of source files!
      How can that be a tiny OS?
      Actually, the large number of files is one of the tricks to keep NuttX small and
      as scalable as possible.
      Most files contain only a single function. 
      Sometimes just one tiny function with only a few lines of code.
      Why?
    </p>
    <ul>
      <li>
        <b>Static Libraries</b>.
        Because in the NuttX build processed, objects are compiled and saved into
        <i>static libraries</i> (<i>archives</i>).
        Then, when the file executable is linked, only the object files that are needed
        are extracted from the archive and added to the final executable.
        By having many, many tiny source files, you can assure that no code that you do
        not execute is ever included in the link.
        And by having many, tiny source files you have better granularity --
        if you don't use that tiny function of even just a few lines of code, it will
        not be included in the binary.
      </li>
    </ul>
  </td>
</tr>

<tr>
  <td valign="top" width="22"><img height="20" width="20" src="favicon.ico"></td>
  <td bgcolor="#5eaee1">
    <b>Other Tricks</b>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      As mentioned above, the use of many, tiny source files and linking from static
      libraries keeps the size of NuttX down.
      Other tricks used in NuttX include:
    </p>
    <ul>
      <li>
         <b>Configuration Files</b>.
         Before you build NuttX, you must provide a configuration file that specifies
         what features you plan to use and which features you do not.
         This configuration file contains a long list of settings that control
         what is built into NuttX and what is not.
         There are hundreds of such settings
         (see the <a href="NuttxPortingGuide.html#apndxconfigs">NuttX Porting Guide</a>
         for a partial list that excludes platform specific settings).
         These many, many configuration options allow NuttX to be highly tuned to
         meet size requirements.
         The downside to all of these configuration options is that it greatly
         complicates the maintenance of NuttX -- but that is my problem, not yours.
      </li>
      <li>
         <b>Weak Symbols</b>
         The GNU toolchain supports <i>weak</i> symbols and these also help to keep
         the size of NuttX down.
         Weak symbols prevent object files from being drawn into the link even if they
         are accessed from source code.
         Careful use of weak symbols is another trick for keep unused code out of the
         final binary.
      </li>
    </ul>
  </td>
</tr>

</table></center>


<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="group"><h1>NuttX Discussion Group</h1></a>
  </td>
  </tr>
</table>

<p>
  Most NuttX-related discussion occurs on the <a href="http://tech.groups.yahoo.com/group/nuttx/" target="_top"><i>Yahoo!</i> NuttX group</a>.
  You are cordially invited to <a href="http://groups.yahoo.com/group/nuttx/join" target="_top">join</a>.
  I make a special effort to answer any questions and provide any help that I can.
</p>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="downloads"><h1>Downloads</h1></a>
  </td>
  </tr>
</table>

<h2>NuttX-6.26 Release Notes</h2>
<p>
  The 93<sup>rd</sup> release of NuttX, Version 6.26, was made on March 15, 2013, and is available for download from the
  <a href="http://sourceforge.net/projects/nuttx/files/">SourceForge</a> website.
  Note that the release consists of two tarballs:  <code>nuttx-6.26.tar.gz</code> and <code>apps-6.26.tar.gz</code>.
  Both may be needed (see the top-level <code>nuttx/README.txt</code> file for build information)
  The change log associated with the release is available <a href="#currentrelease">here</a>.
  Unreleased changes after this release are available in GIT.
  These unreleased changes are also listed <a href="#pendingchanges">here</a>.
</p>
<p>
  This release corresponds with GIT release number: r5745,
  Note that all GIT information has been stripped from the tarballs.
  If you need the GIT configuration, you should check out directly from GIT.
  Revision r5745 should equivalent to release 6.26 of NuttX:
</p>
<ul><pre>
svn checkout -r5745 svn://svn.code.sf.net/p/nuttx/code/trunk nuttx-code
</pre></ul>
<p>Or (HTTP):</p>
<ul><pre>
svn checkout -r5745 http://svn.code.sf.net/p/nuttx/code/trunk nuttx-code
</pre></ul>
<p>
  <b>Additional new features and extended functionality</b>
</p>
<ul>
  <li>
    <p>
      <b>OS Initialization</b>
    </p>
    <ul>
      <li>
        Add an additional call-out to support board-specific driver initialization during the boot-up phase (available with <code>CONFIG_BOARD_INITIALIZE=y</code>).
    </ul>
  </li>
  <li>
    <p>
      <b>Tasking</b>
    </p>
    <ul>
      <li>
        New interface <code>task_spawn()</code> that is like <code>posix_spawn()</code>, but uses entry point addresses like <code>ask_create()</code>.
      </li>
      <li>
        Additional data restructuring as a continuation of the <i>task group</i> changes of NuttX 6.25.
        These data structures were moved from the TCB structure into the task group:
        pthread join data, <code>atexit</code>/<code>on_exit</code> callbacks, <code>waitpid</code>data structures, message queues.
      </li>
      <li>
        TCBs for tasks and pthreads are now separate structures.
        This saves a little memory since tasks do not have to carry the overhead for threads and vice versa.
      </li>
    </ul>
  </li>
  <li>
    <p>
      <b>Kernel Build</b>
    </p>
    <ul>
      <li>
        Extensive changes were made to support the kernel build mode.
        In this mode, NuttX is built as a monolithic kernel.
        NuttX is built as a separate kernel mode &quot;blob&quot; and the applications are built as a separate user mode &quot;blob&quot;.
        The kernel runs in kernel mode and the applications run in user mode (with the MPU restricting user
        mode accesses).
        Access to the kernel from the user blob is only via system calls (<i>SVCalls</i>).
      </li>
      <li>
        Extensive changes were made to the syscall, SVCall, and trapping logic.
        Many internal interfaces were renamed.
      </li>
      <li>
        The memory manager was extended to support both kernel- and user-mode allocations.
        Logic within the kernel needs to use the correct kernel- or user-space allocator, depending upon the user of the allocated memory.
      </li>
      <li>
        The user-space blob now contains a header built in at the beginning of the block that provides the same information that was previously provided by a kludgy, auto-generated header file (<code>user_map.h</code>).
      </li>
      <li>
        Basic support implemented for the ARMv7-M family with fragments also implemetned for the ARMv6-M and MIPS32 families.
      </li>
      <li>
        Kernel build supported added for the LPC17xx Open1788 and for the Atmel SAM3U-EK board.
        All testing is being performed on the Open1788 board.
      </li>
    </ul>
  </li>
  <li>
    <p>
      <b>Signals</b>
    </p>
    <ul>
      <li>
        Delivery of signals to threads within a task group is now compatible with the way that signals are delivered to threads within a process.
      </li>
    </ul>
  </li>
  <li>
    <p>
      <b>Drivers</b>
    </p>
    <ul>
      <li>
        Add a driver for the SST29VF NOR FLASH parts.
      </li>
      <li>
        USB device trace/debug feature extended to decode device-specific trace events to make the trace output more readable (from Petteri Aimonen).
      </li>
      <li>
        USB MSC device driver can not support names of differing sizes in the USB descriptor and the SCSI fields (from Petteri Aimonen).
      </li>
      <li>
        Locking added to MMC/SD SPI drivers so that MMC/SD can co-exist on the same bus as other SPI devices.
        Frequency is reset each time that the MMC/SD SPI has the bus locked. (from Petteri Aimonen).
      </li>
    </ul>
  </li>
  <li>
    <p>
      <b>ARMv6-M (Cortex-M0)</b>
    </p>
    <ul>
      <li>
        Added support for the ARM Cortex-M0 family.
      </li>
    </ul>
  </li>
  <li>
    <p>
      <b>nuvoTon NUC120</b>
    </p>
    <ul>
      <li>
        Added support for the nuvoTon NUC120 MCU (Cortex-M0).
      </li>
    </ul>
  </li>
  <li>
    <p>
      <b>nuvoTon NUC120 Boards</b>
    </p>
    <ul>
      <li>
        Added basic support for the nuvoTon NuTiny-SDK-NUC120 board (Cortex-M0).
      </li>
    </ul>
  </li>
  <li>
    <p>
      <b>LPC17xx</b>
    </p>
    <ul>
      <li>
        Added support for the LPC177x and LPC178x families.
        Most of this is the work of Rommel Marcelo.
      </li>
    </ul>
  </li>
  <li>
    <p>
      <b>LPC17xx Boards</b>
    </p>
    <ul>
      <li>
        Added support for Zilogic System's ARM development Kit, ZKIT-ARM-1769.
        From Rashid.
      </li>
      <li>
        The port for the WaveShare Open1788 board is now functional.
        Basic OS test and NuttShell (NSH) configurations are functional.
        More driver development and testing is needed (from Rommel Marcelo).
      </li>
    </ul>
  </li>
  <li>
    <p>
      <b>LPC17xx Drivers</b>
    </p>
    <ul>
      <li>
        Added an SD card MSI driver for the LPC178x.
        The driver is marginally functional but requires DMA capability to be reliable.
      </li>
    </ul>
  </li>
  <li>
    <p>
      <b>STM32</b>
    </p>
    <ul>
      <li>
        Support extended to handle the STM32 F3 family (Cortex-M4 with F1-like peripherals).
      </li>
    </ul>
  </li>
  <li>
    <p>
      <b>STM32 Boards</b>
    </p>
    <ul>
      <li>
        Added support the STMicro STM32F3Discovery board (STM32 F3).
      </li>
    </ul>
  </li>
  <li>
    <p>
      <b>Stellaris LM3S/LM4F</b>
    </p>
    <ul>
      <li>
        Basic support for the LM4F120 family is in place, but untested (mostly from Jose Pablo Carballo).
      </li>
    </ul>
  </li>
  <li>
    <p>
      <b>Stellaris LM4F Boards</b>
    </p>
    <ul>
      <li>
        Add support for the LM4F120 LaunchPad (untested).
      </li>
    </ul>
  </li>
  <li>
    <p>
      <b>Networking</b>
    </p>
    <ul>
      <li>
        <code>select()</code> should now allocate a little less memory.
      </li>
    </ul>
  </li>
  <li>
    <p>
      <b>Memory Management</b>
    </p>
    <ul>
      <li>
        Extended to support multiple heaps.
        This is used as part of the kernel build in order to support separater user- and kernel-mode heaps.
      </li>
      <li>
        The stand-alone memory manger test had to be removed.
        It was too entangled and made extension of the memory manager nearly impossible.
        This is a loss.
      </li>
    </ul>
  </li>
  <li>
    <p>
      <b>Build System</b>
    </p>
    <ul>
      <li>
        Several configurations converted to use the <i>kconfig-frontends</i> configuration tool.
        There are still many more that need to be converted.
      </li>
    </ul>
  </li>
  <li>
    <p>
      <b>C Library</b>
    </p>
    <ul>
      <li>
        Move the workqueue logic into the C library.
        There is now a special user-space version of the work queue (which will only be used with a NuttX kernel build).
      </li>
      <li>
        Implementation of <code>itoa()</code> contributed by Ryan Sundberg.
      </li>
    </ul>
  </li>
  <li>
    <p>
      <b>Applications</b>
    </p>
    <ul>
      <li>
        The NSH builtin task logic now uses <code>task_spawn()</code> to start builtin applications.
      </li>
      <li>
        The OS test now includes a test cased to verify <code>task_restart()</code>.
      </li>
    </ul>
  </li>
</ul>
<p>
  <b>Efforts In Progress</b>.
  The following are features that are partially implemented but present in this release.
  Most are expected to be fully available in NuttX 6.27.
</p>
<ul>
  <li>
    <p>
      <b>LM4F120 LaunchPad port</b>
    </p>
    <ul>
      <li>
        Code is in place, but nothing has been tested.
      </li>
    </ul>
  </li>
  <li>
    <p>
      <b>WaveShare Open1788 port</b>
    </p>
    <ul>
      <li>
        This port as actually complete and functional.
        However, there is still ongoing development and testing of drivers.
      </li>
    </ul>
  </li>
  <li>
    <p>
      <b>Kernel Build</b>
    </p>
    <ul>
      <li>
        Much progress has been made, but there kernel build is not yet fully functional due to several user resources that are not yet properly disentangled from the kernel blob.
      </li>
    </ul>
  </li>
  <li>
    <p>
      <b><i>kconfig-frontends</i></b>
    </p>
    <ul>
      <li>
        Conversion of old configurations to use the <i>kconfig-frontends</i> tool is an ongoing effort that will continue for some time.
      </li>
    </ul>
  </li>
</ul>
<p>
  <b>Bugfixes</b> (see the change log for details).
  Some of these are very important:
</p>
<ul>
  <li>
    <p>
      <b>Tasking</b>
    </p>
    <ul>
      <li>
        The wrong PID was being signalled with <code>SIGCHILD</code>.
        It should be  the PID of the task that create the task group, not the ID of the last thread to leave the task group.
      </li>
      <li>
        Added logic so that some internal resources and states are recovered when tasks are deleted or restarted.
        Handle cases where there are outstanding timed events pending when tasks are deleted or restarted.
      </li>
    </ul>
  </li>
  <li>
    <p>
      <b>ARMv7-M</b>
    </p>
    <ul>
      <li>
        Several fixes to the MPU control logic.
      </li>
    </ul>
  </li>
  <li>
    <p>
      <b>Drivers</b>
    </p>
    <ul>
      <li>
        Removable serial drivers race conditions fixed.
      </li>
      <li>
        MAX11802 timing bug (from Petteri Aimonen).
      </li>
    </ul>
  </li>
  <li>
    <p>
      <b>STM32 Drivers</b>
    </p>
    <ul>
      <li>
        Handle cases were SPI DMA logic fails if <code>sem_wait()</code> is awakened by a signal.
        Need to clear error flags to prevent corruption of subsequent transfers.
        Also, bit count should not be changed while the SPI peripheral is enabled (from Petteri Aimonen).
      </li>
      <li>
        Fixes to the OTG FS device driver from Petteri Aimonen.
      </li>
      <li>
        Fix typos in DMA register header file (from Yan T.)
      </li>
    </ul>
  </li>
  <li>
    <p>
      <b>Graphics</b>
    </p>
    <ul>
      <li>
        Correction to the hyphen in the SANS 17x22 font (from Petteri Aimonen).
      </li>
    </ul>
  </li>
  <li>
    <p>
      <b>Networking</b>
    </p>
    <ul>
      <li>
        Corrected errors in the socket <code>poll</code>/<code>select</code> logic.  Additional
        state logic was needed to detect if the socket is still connected
        before starting the poll wait. (bug reported by Qiang Yu).
      </li>
    </ul>
  </li>
  <li>
    <p>
      <b>Memory Management</b>
    </p>
    <ul>
      <li>
        <code>mallinfo()</code> should hold the memory manager semaphore (from Petteri Aimonen.
      </li>
    </ul>
  </li>
  <li>
    <p>
      <b>Build System</b>
    </p>
    <ul>
      <li>
        Resolved several build errors reported by Mike Smith.
      </li>
    </ul>
  </li>
  <li>
    <p>
      <b>Applications</b>
    </p>
    <ul>
      <li>
        Fixed an NSH memory leak:
        Needed to detach after creating each pthread.
      </li>
      <li>
        <code>readline()</code> now returns <code>EOF</code> on any failure (instead of a negated <code>errno</code> value).
        This is because the underlying read is based on logic similar to <code>getc</code>.
        The value zero (meaning end-of-file) was being confused with a NUL.
        So if a NUL was received, the NSH session would terminate because it thought it was the end of file.
      </li>
    </ul>
  </li>
</ul>
<p>
  See the <a href="#currentrelease">ChangeLog</a> for additional, detailed changes.
</p>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="platforms"><h1>Supported Platforms</h1></a>
  </td>
  </tr>
</table>

<p>
  The short story (Number of ports follow in parentheses).
  The state of the various ports vary from board-to-board.
  Follow the links for the details:
</p>
<center><table width="90%">
<ul>
  <tr>
  <td bgcolor="#e4e4e4" valign="top">
  <li><a href="#linuxusermode">Linux user mode simulation</a> (1)</li>
  <li>ARM
    <ul>
      <li><a href="#arm7tdmi">ARM7TDMI</b></a> (5)</li>
      <li><a href="#arm920t">ARM920T</a> (1) </li>
      <li><a href="#arm926ejs">ARM926EJS</a> (3) </li>
      <li><a href="#armcortexm0">ARM Cortex-M0/M0+</a> (2)</li>
      <li><a href="#armcortexm3">ARM Cortex-M3</a> (17)</li>
      <li><a href="#armcortexm4">ARM Cortex-M4</a> (7)</li>
    </ul>
  <li>Atmel AVR
    <ul>
      <li><a href="#atmelavr">Atmel 8-bit AVR</a> (3) </li>
      <li><a href="#atmelavr32">Atmel AVR32</a> (1) </li>
    </ul>
  </li>
  </td>
  <td bgcolor="#e4e4e4" valign="top">
  <li>Freescale <a href="#m68hcs12">M68HCS12</a> (2) </li>
  <li>Intel
    <ul>
      <li><a href="#8052">Intel 8052 Microcontroller</a> (1)</li>
      <li><a href="#80x86">Intel 80x86</a> (2)</li>
    </ul>
  </li>
  <li>MicroChip <a href="#pic32mips">PIC32MX</a> (MIPS) (4)</li>
  <li>Renesas/Hitachi:
    <ul>
        <li><a href="#superh">Renesas/Hitachi SuperH</a> (1/2)</li>
        <li><a href="#m16c">Renesas M16C/26</a> (1/2)</li>
    </ul>
  </li>
  </td>
  <td bgcolor="#e4e4e4" valign="top">
  <li>ZiLOG
    <ul>
        <li><a href="#zilogz16f">ZiLOG Z16F</a> (1)</li>
        <li><a href="#zilogez80acclaim">ZiLOG eZ80 Acclaim!</a> (1)</li>
        <li><a href="#zilogz8encore">ZiLOG Z8Encore!</a> (2)</li>
        <li><a href="#zilogz180">ZiLOG Z180</a> (1)</li>
        <li><a href="#zilogz80">ZiLOG Z80</a> (2)</li>
    </ul>
  </li>
</ul>
  </tr>
</table></center>

<p>The details, caveats and fine print follow:</p>

<center><table width="90%">
<tr>
  <td valign="top"><img height="20" width="20" src="favicon.ico"></td>
  <td bgcolor="#5eaee1">
    <a name="linuxusermode"><b>Linux User Mode</b>.</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      A user-mode port of NuttX to the x86 Linux/Cygwin platform is available.
      The purpose of this port is primarily to support OS feature development.
    </p>
    <ul>
      <p>
        <b>STATUS:</b>
        Does not support interrupts but is otherwise fully functional.
      </p>
    </ul>
   </td>
</tr>
<tr>
  <td valign="top"><img height="20" width="20" src="favicon.ico"></td>
  <td bgcolor="#5eaee1">
    <a name="arm7tdmi"><b>ARM7TDMI</b></a>.
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <b>TI TMS320C5471</b> (also called <b>C5471</b> or <b>TMS320DA180</b> or <b>DA180</b>).
      NuttX operates on the ARM7 of this dual core processor.
      This port uses the <a href="http://www.spectrumdigital.com/">Spectrum Digital</a>
      evaluation board with a GNU arm-nuttx-elf toolchain* under Linux or Cygwin.
    </p>
    <ul>
      <p>
        <b>STATUS:</b>
        This port is complete, verified, and included in the initial NuttX release.
      </p>
    </ul>
   </td>
</tr>
<tr>
  <td><br></td>
  <td><hr></td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <b>TI Calypso</b>.
      This port supports the TI &quot;Calypso&quot; MCU used in various cell phones (and, in particular,
      by the <a href="http://bb.osmocom.org/trac/">Osmocom-bb project</a>).
      Like the c5471, NuttX operates on the  ARM7 of this dual core processor.
    </p>
    <ul>
      <p>
        <b>STATUS:</b>
        This port was contributed by  Denis Carilki and includes the work of Denis Carikli, Alan Carvalho de Assis, and Stefan Richter.
        Calypso support first appeared in NuttX-6.17 with LCD drivers.
        Support for the Calypso keyboard was added in NuttX-6.24 by Denis Carilki.
      </p>
    </ul>
  </td>
</tr>
<tr>
  <td><br></td>
  <td><hr></td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <b>NXP LPC214x</b>.
      Support is provided for the NXP LPC214x family of processors.  In particular,
      support is provided for (1) the mcu123.com lpc214x evaluation board (LPC2148)
      and (1) the The0.net ZPA213X/4XPA development board (with the The0.net UG-2864AMBAG01 OLED)
      This port also used the GNU arm-nuttx-elf toolchain* under Linux or Cygwin.
    </p>
    <ul>
      <p>
        <b>STATUS:</b>
        This port boots and passes the OS test (apps/examples/ostest).
        The port is complete and verified.  As of NuttX 0.3.17, the port includes:
        timer interrupts, serial console, USB driver, and SPI-based MMC/SD card
        support.  A verified NuttShell (<a href="NuttShell.html">NSH</a>)
        configuration is also available.
      </p>
      <p>
        <b>Development Environments:</b>
        1) Linux with native Linux GNU toolchain, 2) Cygwin/MSYS with Cygwin GNU toolchain, 3) Cygwin/MSYS
        with Windows native toolchain (CodeSourcery or devkitARM), or 4) Native Windows.  A DIY toolchain for Linux
        or Cygwin is provided by the NuttX
        <a href="http://sourceforge.net/projects/nuttx/files/buildroot/">buildroot</a>
        package.
      </p>
    </ul>
  </td>
</tr>
<tr>
  <td><br></td>
  <td><hr></td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <b>NXP LPC2378</b>.
      Support is provided for the NXP LPC2378 MCU.  In particular,
      support is provided for the Olimex-LPC2378 development board.
      This port was contributed by Rommel Marcelo is was first released in NuttX-5.3.
      This port also used the GNU arm-nuttx-elf toolchain* under Linux or Cygwin.
    </p>
    <ul>
      <p>
        <b>STATUS:</b>
        This port boots and passes the OS test (apps/examples/ostest) and includes a
        working implementation of the NuttShell (<a href="NuttShell.html">NSH</a>).
        The port is complete and verified.
        As of NuttX 5.3, the port includes only basic timer interrupts and serial console support.
      </p>
      <p>
        <b>Development Environments:</b> (Same as for the NXP LPC214x).
      </p>
    </ul>
  </td>
</tr>
<tr>
  <td><br></td>
  <td><hr></td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <b>STMicro STR71x</b>.
      Support is provided for the STMicro STR71x family of processors.  In particular,
      support is provided for the Olimex STR-P711 evaluation board.
      This port also used the GNU arm-nuttx-elf toolchain* under Linux or Cygwin.
    </p>
    <ul>
      <p>
        <b>STATUS:</b>
        Integration is complete on the basic port (boot logic, system time, serial console).
        Two configurations have been verified: (1) The board boots and passes the OS test
        with console output visible on UART0, and the NuttShell (<a href="NuttShell.html">NSH</a>)
        is fully functional with interrupt driven serial console.  An SPI driver is available
        but only partially tested.  Additional features are needed: USB driver, MMC integration,
        to name two (the slot on the board appears to accept on MMC card dimensions; I have only
        SD cards).
        An SPI-based ENC28J60 Ethernet driver for add-on hardware is available and
        but has not been fully verified on the Olimex board (due to issues powering the ENC28J60 add-on board).
      </p>
      <p>
        <b>Development Environments:</b>
        1) Linux with native Linux GNU toolchain, 2) Cygwin/MSYS with Cygwin GNU toolchain, 3) Cygwin/MSYS
        with Windows native toolchain (CodeSourcery or devkitARM), or 4) Native Windows.  A DIY toolchain for Linux
        or Cygwin is provided by the NuttX
        <a href="http://sourceforge.net/projects/nuttx/files/buildroot/">buildroot</a>
        package.
      </p>
    </ul>
  </td>
</tr>
<tr>
  <td valign="top"><img height="20" width="20" src="favicon.ico"></td>
  <td bgcolor="#5eaee1">
    <a name="arm920t"><b>ARM920T</b>.</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <b>Freescale MC9328MX1</b> or <b>i.MX1</b>.
      This port uses the Freescale MX1ADS development board with a GNU arm-nuttx-elf toolchain*
      under either Linux or Cygwin.
    </p>
    <ul>
      <p>
        <b>STATUS:</b>
          This port has stalled due to development tool issues.
          Coding is complete on the basic port (timer, serial console, SPI).
      </p>
    </ul>
   </td>
</tr>
<tr>
  <td valign="top"><img height="20" width="20" src="favicon.ico"></td>
  <td bgcolor="#5eaee1">
    <a name="arm926ejs"><b>ARM926EJS</b>.</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <b>TI TMS320DM320</b> (also called <b>DM320</b>).
      NuttX operates on the ARM9 of this dual core processor.
      This port uses the
      <a href="http://wiki.neurostechnology.com/index.php/Developer_Welcome">Neuros OSD</a>
      with a GNU arm-nuttx-elf toolchain* under Linux or Cygwin.
      The port was performed using the OSD v1.0, development board.
    </p>
    <ul>
      <p>
        <b>STATUS:</b>
          The basic port (timer interrupts, serial ports, network, framebuffer, etc.) is complete.
          All implemented features have been verified with the exception of the USB device-side
          driver; that implementation is complete but untested.
      </p>
    </ul>
  </td>
</tr>
<tr>
  <td><br></td>
  <td><hr></td>
</tr>
<tr>
  <td><br></td>
  <td>
    <b>NXP <a href="http://ics.nxp.com/products/lpc3000/lpc313x.lpc314x.lpc315x/">LPC3131</a></b>.
    The port for the NXP LPC3131 on the <a href="http://www.embeddedartists.com/products/kits/lpc3131_kit.php">Embedded Artists EA3131</a> 
    development board was first released in NuttX-5.1 with a GNU arm-nuttx-elf or arm-eabi toolchain* under Linux or Cygwin
    (but was not functional until NuttX-5.2).
    </p>
    <ul>
      <p>
        <b>STATUS:</b>
          The basic EA3131 port is complete and verified in NuttX-5.2 
          This basic port includes basic boot-up, serial console, and timer interrupts.
          This port was extended in NuttX 5.3 with a USB high speed driver contributed by David Hewson.
          David also contributed I2C and SPI drivers plus several important LPC313x USB bug fixes
          that appear in the NuttX 5.6 release.
          This port has been verified using the NuttX OS test, USB serial and mass storage
          tests and includes a working implementation of the NuttShell (<a href="NuttShell.html">NSH</a>).
      </p>
      <p>
          Support for <a href="NuttXDemandPaging.html">on-demand paging</a> has been developed for the EA3131.
      That support would all execute of a program in SPI FLASH by paging code sections out of SPI flash as needed.
      However, as of this writing, I have not had the opportunity to verify this new feature.
      </p>
    </ul>
  </td>
</tr>
<tr>
  <td><br></td>
  <td><hr></td>
</tr>
<tr>
  <td><br></td>
  <td>
    <b>NXP <a href="http://ics.nxp.com/products/lpc3000/lpc313x.lpc314x.lpc315x/">LPC315x</a></b>.
    Support for the NXP LPC315x family has been incorporated into the code base as of NuttX-6.4.
    Support has added for the Embedded Artists EA3152 board in NuttX-6.11.
    </p>
    <ul>
      <p>
        <b>STATUS:</b>
          Basic support is in place for both the LPC3152 MCU and the EA3152 board.
          Verification of the port was deferred due to tool issues
          However, because of the high degree of compatibility between the LPC313x and LPC315x family, it
          is very likely that the support is in place (or at least very close).
          At this point, verification of the EA3152 port has been overcome by events and
          may never happen.
          However, the port is available for anyone who may want to use it.
      </p>
    </ul>
  </td>
</tr>
<tr>
  <td valign="top"><img height="20" width="20" src="favicon.ico"></td>
  <td bgcolor="#5eaee1">
    <a name="armcortexm0"><b>ARM Cortex-M0</b>.</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <b>NuvoTon NUC120</b>.
      This is a port of NuttX to the Nuvoton NuTiny-SDK-NUC120 that features the NUC120LE3AN MCU.
    </p>
    <ul>
      <p>
        <b>STATUS</b>.
        Initial support for the NUC120 was released in NuttX-6.26.
        This initial support is very minimal:
        There is an OS test configuration that verifies the correct port of NuttX to the part and
        a NuttShell (<a href="NuttShell.html">NSH</a>) configuration that might be the basis for an application development.
        As of this writing, more device drivers are needed to make this a more complete port.
      </p>
      <p>
        <b>Memory Usage</b>.
        For a full-featured RTOS such as NuttX, providing support in a usable and meaningful way within the tiny memories of the NUC120 demonstrates the scalability of NuttX.  The NUC120LE2AN comes in a 48-pin package and has 128KB FLASH and 16KB of SRAM.
        When running the NSH configuration (itself a full up application), there is still more than 90KB of FLASH and 10KB or SRAM available for further application development).
      </p>
      <p>
        Static memory usage can be shown with <code>size</code> command:
      </p>
      <ul><pre>
$ size nuttx
   text    data     bss     dec     hex filename
  35037     106    1092   36235    8d8b nuttx
</pre></ul>
      <p>
        NuttX, the NSH application, and GCC libraries use 34.2KB of FLASH leaving 93.8KB of FLASH (72%) free from additional application development.
        Static SRAM usage is about 1.2KB (&lt;4%) and leaves 13.8KB (86%) available for heap at runtime.
        SRAM usage at run-time can be shown with the NSH <code>free</code> command:
      </p>
      <ul><pre>
NuttShell (NSH) NuttX-6.26
nsh> free
             total       used       free    largest
Mem:         14160       3944      10216       10216
nsh>
</pre></ul>
    <p>
      You can see that 10.0KB (62%) is available for further application development.
    </p>
    <p>
      <b>Development Environments:</b>
      1) Linux with native Linux GNU toolchain, 2) Cygwin/MSYS with Cygwin GNU toolchain, 3) Cygwin/MSYS
      with Windows native toolchain, or 4) Native Windows.
      A DIY toolchain for Linux or Cygwin is provided by the NuttX
      <a href="http://sourceforge.net/projects/nuttx/files/buildroot/">buildroot</a> package.
    </p>
  </td>
</tr>
<tr>
  <td><br></td>
  <td><hr></td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <b>FreeScale Freedom KL25Z</b>.
      This is a port of NuttX to the Nuvoton NuTiny-SDK-NUC120 that features the NUC120LE3AN MCU.
      See the <a href="http://www.freescale.com/webapp/sps/site/prod_summary.jsp?code=FRDM-KL25Z&tid=vanFRDM-KL25Z">Freescale</a> website for further information about this board.
    </p>
    <ul>
      <p>
        <b>STATUS</b>.
        This is a work in progress by Alan Carvalho de Assis.
        This initial support is very minimal:
        There is an OS test configuration that verifies the correct port of NuttX to the part and
        a NuttShell (<a href="NuttShell.html">NSH</a>) configuration that might be the basis for an application development.
        As of this writing, more testing and more device driver development are needed to make this a more complete port.
      </p>
    </ul>
  </td>
</tr>
<tr>
  <td valign="top"><img height="20" width="20" src="favicon.ico"></td>
  <td bgcolor="#5eaee1">
    <a name="armcortexm3"><b>ARM Cortex-M3</b>.</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <b>TI Stellaris LM3S6432</b>.
      This is a port of NuttX to the Stellaris RDK-S2E Reference Design Kit and the MDL-S2E Ethernet to Serial module
      (contributed by Mike Smith).
    </p>
  </td>
</tr>
<tr>
  <td><br></td>
  <td><hr></td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <b>Luminary/TI Stellaris LM3S6918</b>.
      This port uses the <a href=" http://www.micromint.com/">Micromint</a> Eagle-100 development
      board with a GNU arm-nuttx-elf toolchain* under either Linux or Cygwin.
    </p>
    <ul>
      <p>
        <b>STATUS:</b>
          The initial, release of this port was included in NuttX  version 0.4.6.
          The current port includes timer, serial console, Ethernet, SSI, and microSD support.
          There are working configurations the NuttX OS test, to run the <a href="NuttShell.html">NuttShell
          (NSH)</a>, the NuttX networking test, and the uIP web server.
      </p>
     </ul>
    <p>
      <b>Development Environments:</b>
      1) Linux with native Linux GNU toolchain, 2) Cygwin/MSYS with Cygwin GNU toolchain, 3) Cygwin/MSYS
      with Windows native toolchain (CodeSourcery or devkitARM), or 4) Native Windows.  A DIY toolchain for Linux
      or Cygwin is provided by the NuttX
      <a href="http://sourceforge.net/projects/nuttx/files/buildroot/">buildroot</a>
      package.
    </p>
  </td>
</tr>
<tr>
  <td><br></td>
  <td><hr></td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <b>Luminary/TI Stellaris LM3S6965</b>.
      This port uses the Stellaris LM3S6965 Ethernet Evalution Kit with a GNU arm-nuttx-elf toolchain*
      under either Linux or Cygwin.
    </p>
    <ul>
      <p>
        <b>STATUS:</b>
          This port was released in NuttX 5.5.  
          Features are the same as with the Eagle-100 LM3S6918 described above.
          The apps/examples/ostest configuration has been successfully verified and an
          NSH configuration with Telnet support is available.
          MMC/SD and Networking support was not been thoroughly verified:
          Current development efforts are focused on porting the NuttX window system (NX)
          to work with the Evaluation Kits OLED display.
      </p>
      <p><small>
         <b>NOTE</b>: As it is configured now, you MUST have a network connected.
         Otherwise, the NSH prompt will not come up because the Ethernet
         driver is waiting for the network to come up.
      </small></p>
     </ul>
    <p>
      <b>Development Environments:</b> See the Eagle-100 LM3S6918 above.
    </p>
   </td>
</tr>
<tr>
  <td><br></td>
  <td><hr></td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <b>Luminary/TI Stellaris LM3S8962</b>.
      This port uses the Stellaris EKC-LM3S8962 Ethernet+CAN Evalution Kit with a GNU arm-nuttx-elf toolchain*
      under either Linux or Cygwin.
      Contributed by Larry Arnold.
    </p>
    <ul>
      <p>
        <b>STATUS:</b>
          This port was released in NuttX 5.10. 
          Features are the same as with the Eagle-100 LM3S6918 described above.
      </p>
     </ul>
   </td>
</tr>
<tr>
  <td><br></td>
  <td><hr></td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <b>Luminary/TI Stellaris LM3S9B96</b>.
      Header file support was contributed by Tiago Maluta for this part.
      Jose Pablo Rojas V. is currently using those header file changes to port NuttX to the TI/Stellaris EKK-LM3S9B96.
      With any luck, that port should be working and available in the NuttX-6.20 release.
    </p>
  </td>
</tr>
<tr>
  <td><br></td>
  <td><hr></td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <b>TI Stellaris LM3S6432S2E</b>.
      This port uses Serial-to-Ethernet Reference Design Kit (<a href="http://www.ti.com/tool/rdk-s2e">RDK-S2E</a>)
      and has similar support as for the other Stellaris family members.
      Configurations are available for the OS test and for the NuttShell (NSH)
      (see the <a href="http://www.nuttx.org/Documentation/NuttShell.html">NSH User Guide</a>).
      The NSH configuration including networking support with a Telnet NSH console.
      This port was contributed by Mike Smith.
    </p>
    <ul>
      <p>
        <b>STATUS:</b>
          This port was will be released in NuttX 6.14. 
      </p>
     </ul>
  </td>
</tr>
<tr>
  <td><br></td>
  <td><hr></td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <b>STMicro STM32F100x (STM32 F1 &quot;Value Line&quot;Family)</b>.
      Chip support for these STM32 &quot;Value Line&quot; family was contributed by Mike Smith and users have reported that they have successful brought up NuttX on there proprietary boards using this logic.
      This logic was extended to support the <i>high density</i> STM32F100RC chips by Freddie Chopin
      However, there is <i>no</i> specific board support for this chip families in the NuttX source tree.
      There is, however, <i>generic</i> support for STM32F100RC boards.
    </p>
</tr>
<tr>
  <td><br></td>
  <td><hr></td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <b>STMicro STM32F103x (STM32 F1 Family)</b>.
      Support for four MCUs and four board configurations are available.
      MCU support includes all of the high density and connectivity line families.
      Board supported is available specifically for: STM32F103ZET6, STM32F103RET6, STM32F103VCT, and STM32F103VET6.
      Boards supported include:
    </p>
    <ol>
      <li>
        A port for the <a href=" http://www.st.com/">STMicro</a> STM3210E-EVAL development board that
        features the STM32F103ZET6 MCU.
      </li>
      <li>
        The ISOTEL NetClamps VSN V1.2 ready2go sensor network platform based on the
        STMicro STM32F103RET6.  Contributed by Uros Platise.
      </li>
      <li>
        A port for the HY-Mini STM32v board.  This board is based on the
        STM32F103VCT chip.  Contributed by Laurent Latil.
      </li>
      <li>
         The M3 Wildfire development board (STM32F103VET6), version 2.
         See <a href="http://firestm32.taobao.com">http://firestm32.taobao.com</a> (the current board is version 3).
      </li>
    </ol>
    <p>
      These ports uses a GNU arm-nuttx-elf toolchain* under either Linux or Cygwin (with native Windows GNU tools or Cygwin-based GNU tools).
    </p>
    <ul>
      <p>
        <b>STATUS:</b>
      </p>
      <ul>
        <li><b>Basic Support/Drivers</b>.
          The basic STM32 port was released in NuttX version 0.4.12. The basic port includes boot-up
          logic, interrupt driven serial console, and system timer interrupts.
          The 0.4.13 release added support for SPI, serial FLASH, and USB device.;
          The 4.14 release added support for buttons and SDIO-based MMC/SD and verifed DMA support.
          Verified configurations are available for NuttX OS test, the NuttShell (NSH) example,
          the USB serial device class, and the USB mass storage device class example.
        </li>
        <li><b>NetClamps VSN</b>.
          Support for the NetClamps VSN was included in version 5.18 of NuttX.
          Uros Platise added support for timers, RTC, I2C, FLASH, extended power management
          and other features.
        </li>
        <li><b>Additional Drivers</b>.
          Additional drivers and configurations were added in NuttX 6.13 and later releases for the STM32 F1 and F4.
          F1 compatible drivers include an Ethernet driver, ADC driver, DAC driver, PWM driver, IWDG, WWDG, and CAN drivers.
        </li>
        <li><b>M3 Wildfire</b>.
          Support for the Wildfire board was included in version 6.22 of NuttX.
          The board port is basically functional.
          Not all features have been verified.
          Support for FAT file system on an an SD card had been verified.
          The ENC28J60 network is functional (but required lifting the chip select pin on the W25x16 part).
          Customizations for the v3 version of the Wildfire board are selectable (but untested).
        </li>
      </ul>
     </ul>
     <p>
       <b>Development Environments:</b>
       1) Linux with native Linux GNU toolchain, 2) Cygwin/MSYS with Cygwin GNU toolchain, 3) Cygwin/MSYS
       with Windows native toolchain (RIDE7, CodeSourcery or devkitARM), or 4) Native Windows.  A DIY toolchain or Linux
       or Cygwin is provided by the NuttX
       <a href="http://sourceforge.net/projects/nuttx/files/buildroot/">buildroot</a>
       package.
     </p>
  </td>
</tr>
<tr>
  <td><br></td>
  <td><hr></td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <b>STMicro STM32F107x (STM32 F1 &quot;Connectivity Line&quot; family)</b>.
      Chip support for the STM32 F1 &quot;Connectivity Line&quot; family has been present in NuttX for some time and users have reported that they have successful brought up NuttX on there proprietary boards using this logic.
    </p>
    <p>
      <b>Olimex STM32-P107</b>
      Support for the <a href="https://www.olimex.com/dev/stm32-p107.html">Olimex STM32-P107</a> was contributed by Max Holtzberg and first appeared in NuttX-6.21.  That port features the STMicro STM32F107VC MCU.
      <ul>
        <b>STATUS:</b>
        Configurations for the basic OS test and NSH are available and verified.
        Networking is functional.
      </ul>
    </p>
    <p>
      <b>Shenzhou IV</b>
      Work is underway as of this writing to port NuttX to the Shenzhou IV development board (See <a href="http://www.armjishu.com">www.armjishu.com</a>) featuring the STMicro STM32F107VCT MCU.
      If all goes according to plan, this port should be verified and available in NuttX-6.22.
      <ul>
        <b>STATUS:</b>
        In progress.
        The following have been verified:
        (1) Basic Cortex-M3 port, 
        (2) Ethernet,
        (3) On-board LEDs
      </ul>
    </p>
   </td>
</tr>
<tr>
  <td><br></td>
  <td><hr></td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <b>STMicro STM32F207IG (STM32 F2 family)</b>.
      Support for the STMicro STM3220G-EVAL development board was contributed by Gary Teravskis and first released in NuttX-6.16.
    </p>
    <ul>
      <b>STATUS:</b>
      The peripherals of the STM32 F2 family are compatible with the STM32 F4 family.
      See discussion of the STM3240G-EVAL board below for further information.
      </ul>
   </td>
</tr>
<tr>
  <td><br></td>
  <td><hr></td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <b>Atmel AT91SAM3U</b>.
      This port uses the <a href="http://www.atmel.com/">Atmel</a> SAM3U-EK
      development board that features the AT91SAM3U4E MCU.
      This port uses a GNU arm-nuttx-elf or arm-eabi toolchain* under either Linux or Cygwin (with native Windows GNU tools or Cygwin-based GNU tools).
    </p>
    <ul>
      <p>
        <b>STATUS:</b>
        The basic SAM3U-EK port was released in NuttX version 5.1. The basic port includes boot-up
        logic, interrupt driven serial console, and system timer interrupts.
        That release passes the NuttX OS test and is proven to have a valid OS implementation.
        A configuration to support the NuttShell is also included.
        NuttX version 5.4 adds support for the HX8347 LCD on the SAM3U-EK board.
        This LCD support includes an example using the
        <a href=" http://www.nuttx.org/Documentation/NXGraphicsSubsystem.html">NX graphics system</a>.
        NuttX version 6.10 adds SPI support.
      </p>
      <p>
        Subsequent NuttX releases will extend this port and add support for SDIO-based SD cards and
        USB device (and possible LCD support).
        These extensions may or may not happen soon as my plate is kind of full now.
      </p>
     </ul>
     <p>
       <b>Development Environments:</b>
       1) Linux with native Linux GNU toolchain, 2) Cygwin/MSYS with Cygwin GNU toolchain, 3) Cygwin/MSYS
       with Windows native toolchain (CodeSourcery or devkitARM), or 4) Native Windows.  A DIY toolchain for inux
       or Cygwin is provided by the NuttX
       <a href="http://sourceforge.net/projects/nuttx/files/buildroot/">buildroot</a>
       package.
     </p>
  </td>
</tr>
<tr>
  <td><br></td>
  <td><hr></td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <b>NXP LPC1766, LPC1768, and LPC1769</b>.
      Drivers are available for CAN, DAC, Ethernet, GPIO, GPIO interrupts, I2C, UARTs, SPI, SSP, USB host, and USB device.
      Verified LPC17xx onfigurations are available for three boards.
      <ul>
        <li>
          The Nucleus 2G board from <a href="http://www.2g-eng.com/">2G Engineering</a> (LPC1768),
        </li>
        <li>
          The mbed board from <a href="http://mbed.org">mbed.org</a> (LPC1768, Contributed by Dave Marples), and
        </li>
        <li>
          The LPC1766-STK board from <a href="http://www.olimex.com/">Olimex</a> (LPC1766).
        </li>
        <li>
          The Embedded Artists base board with NXP LPCXpresso LPC1768.
        </li>
        <li>
          Zilogic's ZKIT-ARM-1769 board.
        </li>
        <li>
          The <a href="http://micromint.com/">Micromint</a> Lincoln60 board with an NXP LPC1769.
        </li>
      </ul>
    </p>
    <p>
      The Nucleus 2G board, the mbed board, and the LPCXpresso all feature the NXP LPC1768 MCU;
      the Olimex LPC1766-STK board features an LPC1766.
      All use a GNU arm-nuttx-elf or arm-eabi toolchain* under either Linux or Cygwin (with native Windows GNU tools or Cygwin-based GNU tools).
    </p>
    <ul>
      <p>
        <b>STATUS:</b>
        The following summarizes the features that has been developed and verified on individual LPC17xx-based boards.
        These features should, however, be common and available for all LPC17xx-based boards.
      </p>
      <ol>
        <li>
        <p><b>Nucleus2G LPC1768</b></p>
        <ul>
          <li>
            Some initial files for the LPC17xx family were released in NuttX 5.6, but
          </li>
          <li>
            The first functional release for the NXP LPC1768/Nucleus2G occured with NuttX 5.7 with
            Some additional enhancements through NuttX-5.9.
          </li>
        </ul>
      </p>
      <p>
        That initial, 5.6, basic release included <i>timer</i> interrupts and a <i>serial console</i> and was
        verified using the NuttX OS test (<code>apps/examples/ostest</code>).
        Configurations available include include a verified NuttShell (NSH) configuration
        (see the <a href="http://www.nuttx.org/Documentation/NuttShell.html">NSH User Guide</a>).
        The NSH configuration supports the Nucleus2G's microSD slot and additional configurations
        are available to exercise the the USB serial and USB mass storage devices.
        However, due to some technical reasons, neither the SPI nor the USB device drivers are fully verified.
        (Although they have since been verfiied on other platforms; this needs to be revisited on the Nucleus2G).
      </p>
      </li>
      <li>
        <p><b>mbed LPC1768</b></p>
        <ul>
          <li>
            Support for the mbed board was contributed by Dave Marples and released in NuttX-5.11.
          </li>
        </ul>
      </p>
      <p>
        This port includes a NuttX OS test configuration (see <code>apps/examples/ostest</code>).
      </p>
      </li>
      <li>
        <p><b>Olimex LPC1766-STK</b></p>
        <ul>
          <li>
            Support for that Olimex-LPC1766-STK board was added to NuttX 5.13.
          </li>
          <li>
            The NuttX-5.14 release extended that support with an <i>Ethernet driver</i>.
          </li>
          <li>
            The NuttX-5.15 release further extended the support with a functional <i>USB device driver</i> and <i>SPI-based micro-SD</i>.
          </li>
          <li>
            The NuttX-5.16 release added a functional <i>USB host controller driver</i> and <i>USB host mass storage class driver</i>.
          </li>
          <li>
            The NuttX-5.17 released added support for low-speed USB devicers, interrupt endpoints, and a <i>USB host HID keyboard class driver</i>.
          </li>
        </ul>
      </p>
      <p>
        Verified configurations are now available for the NuttX OS test,
        for the NuttShell with networking and microSD support(NSH, see the <a href="http://www.nuttx.org/Documentation/NuttShell.html">NSH User Guide</a>),
        for the NuttX network test, for the <a href="http://acme.com/software/thttpd">THTTPD</a> webserver,
        for USB serial deive and USB storage devices examples, and for the USB host HID keyboard driver.
        Support for the USB host mass storage device can optionally be configured for the NSH example.
        A driver for the <i>Nokia 6100 LCD</i> and an NX graphics configuration for the Olimex LPC1766-STK have been added.
        However, neither the LCD driver nor the NX configuration have been verified as of the the NuttX-5.17 release.
      </p>
      </li>
      <li>
        <p><b>Embedded Artists base board with NXP LPCXpresso LPC1768</b></p>
        <p>
           An fully verified board configuration is included in NuttX-6.2.
           The Code Red toolchain is supported under either Linux or Windows.
           Verifed configurations include DHCPD, the NuttShell (NSH), NuttX graphis (NX), the NuttX OS test, THTTPD, and USB mass storage device.
        </p>
      </li>
      <li>
        <p><b>Zilogic's ZKIT-ARM-1769 board</b></p>
        <p>
          Zilogic System's ARM development Kit, ZKIT-ARM-1769.
          This board is based on the NXP LPC1769.
          The initial release was included NuttX-6.26.
          The Nuttx Buildroot toolchain is used by default.
          This is still a port under development.
          Verifed configurations include the &quot;Hello, World!&quot; example application and a THTTPD demonstration.
        </p>
      </li>
      <li>
        <p><b>Micromint Lincoln60 board with an NXP LPC1769</b></p>
        <p>
           This board configuration was contributed and made available in NuttX-6.20.
           As contributed board support, I am unsure of what all has been verfied and what has not.
           See the Microment website for more information about the <a href="http://micromint.com/Products/lincoln60.html">Lincoln60</a> board.
           More to come.
        </p>
      </li>
      </ol>
     </ul>
     <p>
       <b>Development Environments:</b>
       1) Linux with native Linux GNU toolchain, 2) Cygwin/MSYS with Cygwin GNU toolchain, 3) Cygwin/MSYS
       with Windows native toolchain (CodeSourcery devkitARM or Code Red), or 4) Native Windows.  A DIY toolchain for Linux
       or Cygwin is provided by the NuttX
       <a href="http://sourceforge.net/projects/nuttx/files/buildroot/">buildroot</a> package.
     </p>
  </td>
</tr>
<tr>
  <td><br></td>
  <td><hr></td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <b>NXP LPC1788</b>.
      The port of NuttX to the WaveShare Open1788 is a collaborative effort between Rommel Marcelo and myself
      (with Rommel being the leading contributor and I claiming only a support role).
      You can get more information at the Open1788 board from the WaveShare <a href="http://www.wvshare.com/product/Open1788-Standard.htm">website</a>.
    </p>
    <ul>
      <b>STATUS:</b>
      At present there is a working basic port with OS verification, Nuttshell (<a href="http://www.nuttx.org/Documentation/NuttShell.html">NSH</a>) configurations, and a graphics test configuration.
      The NSH configuration includes verfied support for (DMA-based) SD card interface.
      SDRAM is working.
      The frame-buffer LCD driver is functional and the touchscreen interface is actively underwork.
      Both should be available in the NuttX-6.27 release.
      </ul>
   </td>
</tr>
<tr>
  <td valign="top"><img height="20" width="20" src="favicon.ico"></td>
  <td bgcolor="#5eaee1">
    <a name="armcortexm4"><b>ARM Cortex-M4</b>.</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <b>FreeScale Kinetis K40</b>.
      This port uses the Freescale Kinetis KwikStik K40.
      Refer to the <a href="http://www.freescale.com/webapp/sps/site/prod_summary.jsp?code=KWIKSTIK-K40">Freescale web site</a> for further information about this board.
      The Kwikstik is used with the FreeScale Tower System (mostly just to provide a simple UART connection)
    </p>
    <ul>
      <p>
        <b>STATUS:</b>
        The unverified KwikStik K40 first appeared in NuttX-6.8
        As of this writing, the basic port is complete but I accidentally locked my board during the initial bringup.
        Further development is stalled unless I learn how to unlock the device (or until I get another K40).
        Additional work remaining includes, among other things: (1) complete the basic bring-up,
        (2) bring up the NuttShell NSH, (3) develop support for the SDHC-based SD card,
        (4) develop support for USB host and device, and (2) develop an LCD driver.
        NOTE: Some of these remaining tasks are shared with the K60 work described below.
      </p>
    </ul>
  </td>
</tr>
<tr>
  <td><br></td>
  <td><hr></td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <b>FreeScale Kinetis K60</b>.
      This port uses the Freescale Kinetis TWR-K60N512 tower system.
      Refer to the <a href="http://www.freescale.com/webapp/sps/site/prod_summary.jsp?code=TWR-K60N512-KIT">Freescale web site</a> for further information about this board.
      The TWR-K60N51 includes with the FreeScale Tower System which provides (among other things) a DBP UART connection.
    </p>
    <ul>
      <p>
        <b>STATUS:</b>
        As of this writing, the basic port is complete and passes the NuttX OS test.
        An additional, validated configuration exists for the NuttShell (NSH, see the
        <a href="http://www.nuttx.org/Documentation/NuttShell.html">NSH User Guide</a>).
        This basic TWR-K60N512 first appeared in NuttX-6.8.
        Ethernet and SD card (SDHC) drivers also exist:
        The SDHC driver is partially integrated in to the NSH configuration but has some outstanding issues;
        the Ethernet driver is completely untested.
        Additional work remaining includes: (1) integrate the Ethernet and SDHC drivers, and (2) develop support for USB host and device.
        NOTE: Most of these remaining tasks (excluding the Ethernet driver) are the same as the pending K40 tasks described above.
      </p>
    </ul>
  </td>
</tr>
<tr>
  <td><br></td>
  <td><hr></td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <b>STMicro STM3240G-EVAL (STM32 F4 family)</b>.
      This port uses the STMicro STM3240G-EVAL board featuring the STM32F407IGH6 MCU.
      Refer to the <a href="http://www.st.com/internet/evalboard/product/252216.jsp">STMicro web site</a> for further information about this board.
    </p>
    <p>
      <b>STATUS:</b>
      <ul>
        <li><b>NuttX-6.12</b>
          The basic port is complete and first appeared in NuttX-6.12.
          The initial port passes the NuttX OS test and includes a validated configuration for the NuttShell (NSH, see the
          <a href="http://www.nuttx.org/Documentation/NuttShell.html">NSH User Guide</a>) as well as several other configurations.
        </li>
        <li><b>NuttX-6.13-6.16</b>
          Additional drivers and configurations were added in NuttX 6.13-6.16.
          Drivers include an Ethernet driver, ADC driver, DAC driver, PWM driver, CAN driver, F4 RTC driver, Quadrature Encoder, DMA, SDIO with DMA
          (these should all be compatible with the STM32 F2 family and many should also be compatible with the STM32 F1 family as well).
        </li>
        <li><b>NuttX-6.16</b>
          The NuttX 6.16 release also includes and logic for saving/restoring F4 FPU registers in context switches.
          Networking intensions include support for Telnet NSH sessions and new configurations for DHPCD and the networking test (nettest).
        </li>
        <li><b>NuttX-6.17</b>
          The USB OTG device controller driver, and LCD driver and a function I2C driver were added in NuttX 6.17.
        </li>
        <li><b>NuttX-6.18</b>
          STM32 IWDG and WWDG watchdog timer drivers were added in NuttX 6.18 (should be compatible with F1 and F2).
          An LCD driver and a touchscreen driver for the STM3240G-EVAL based on the STMPE811 I/O expander were also added in NuttX 6.18.
        </li>
        <li><b>NuttX-6.21</b>
          A USB OTG host controller driver was added in NuttX 6.21.
        </li>
      </p>
  </td>
</tr>
<tr>
  <td><br></td>
  <td><hr></td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <b>STMicro STM32F4-Discovery (STM32 F4 family)</b>.
      This port uses the STMicro STM32F4-Discovery board featuring the STM32F407VGT6 MCU.
      Refer to the <a href="http://www.st.com/internet/evalboard/product/252419.jsp">STMicro web site</a> for further information about this board.
    </p>
    <ul>
      <p>
        <b>STATUS:</b>
        The basic port for the STM32F4-Discovery was contributed by Mike Smith and was first released in NuttX-6.14.
        All drivers listed for the STM3240G-EVAL are usable on this plaform as well.
      </p>
    </ul>
  </td>
</tr>
<tr>
  <td><br></td>
  <td><hr></td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <b>STMicro STM32 F427/437</b>.
      General architectural support was provided for the F427/437 family in NuttX 4.27.
      Specific support includes the STM32F427I, STM32F427Z, and STM32F427V chips.
      This is <i>architecture-only</i> support, meaning that support for the boards with these chips is available, but not support for any publically available boards is included..
      This support was contributed by Mike Smith.
    </p>
    <p>
      The F427/f37 port adds (1) additional SPI ports, (2) additional UART ports, (3) analog and digital noise filters on the I2C ports, (4) up to 2MB of flash, (5) an additional lower-power mode for the internal voltage regulator, (6) a new prescaling option for timer clock, (7) a larger FSMSC write FIFO, and (8) additional crypto modes (F437 only).
    </p>
  </td>
</tr>
<tr>
  <td><br></td>
  <td><hr></td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <b>STMicro STM32F3-Discovery (STM32 F3 family)</b>.
      This port uses the STMicro STM32F3-Discovery board featuring the STM32F303VCT6 MCU (STM32 F3 family).
      Refer to the <a href="http://www.st.com/internet/evalboard/product/254044.jsp">STMicro web site</a> for further information about this board.
    </p>
    <ul>
      <p>
        <b>STATUS:</b>
        The basic port for the STM32F3-Discover was first released in NuttX-6.26.
        Many of the drivers previously released for the STM32 F1, Value Line, and F2 and F4 may be usable on this plaform as well.
        New drivers will be required for ADC and I2C which are very different on this platform.
      </p>
    </ul>
  </td>
</tr>
<tr>
  <td><br></td>
  <td><hr></td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <b>NXG Technologies LPC4330-Xplorer</b>.
      This NuttX port is for the LPC4330-Xplorer board from NGX Technologies featuring the NXP LPC4330FET100 MCU.
      See the <a href="http://shop.ngxtechnologies.com/product_info.php?cPath=21_37&products_id=104">NXG website</a> for further information about this board.
    </p>
    <p>
      <b>STATUS:</b>
    </p>
    <ul>
      <li>
        <p><b>NuttX-6.20</b>
          The basic port is complete.
          The OS test configuration and the basic NSH configurations are present and fully verified.
          This includes verified support for:  SYSTICK system time,  pin and GPIO configuration, and a serial console.
        </p>
        <p>
          Several drivers have been copied from the related LPC17xx port but require integration into the LPC43xx:  ADC, DAC, GPDMA, I2C, SPI, and SSP.
          The registers for these blocks are the same in both the LPC43xx and the LPC17xx and they should integrate into the LPC43xx very easily by simply adapting the clocking and pin configuration logic.
        </p>
        <p>
          Other LPC17xx drivers were not brought into the LPC43xx port because these peripherals have been completely redesigned:  CAN, Ethernet, USB device, and USB host.
        </p>
        <p>
          So then there is no support for the following LPC43xx peripherals: SD/MMC, EMC, USB0,USB1, Ethernet, LCD, SCT, Timers 0-3, MCPWM, QEI, Alarm timer, WWDT, RTC, Event monitor, and CAN.
        </p>
        <p>
          Some of these can be leveraged from other MCUs that appear to support the same peripheral IP:
          <ul>
            <li>
              The LPC43xx USB0 peripheral appears to be the same as the USB OTG peripheral for the LPC31xx.
              The LPC31xx USB0 device-side driver has been copied from the LPC31xx port but also integration into the LPC43xx (clocking and pin configuration).
              It should be possible to complete poriting of this LPC31xx driver with a small porting effort.
            </li>
            <li>
              The Ethernet block looks to be based on the same IP as the STM32 Ethernet and, as a result, it should be possible to leverage the NuttX STM32 Ethernet driver with a little more effort.
            </li>
          </ul>
        </p>
      </li>
      <li>
        <p><b>NuttX-6.21</b>
        Added support for a SPIFI block driver and for RS-485 option to the serial driver.
      </li>
    </ul>
  </td>
</tr>
<tr>
  <td><br></td>
  <td><hr></td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <b>TI Stellaris LM4F120</b>.
      This port uses the TI Stellaris LM4F120 LaunchPad.
      Jose Pablo Carballo and I are doing this port.
    </p>
    <ul>
      <p>
        <b>STATUS:</b>
        As of this writing, the basic port is code complete and fully verified configurations exit for the basic NuttX OS test and for the NuttShell <a href="http://www.nuttx.org/Documentation/NuttShell.html">NSH</a>).
        The first fully functional LM4F120 LaunchPad port was released in NuttX-6.27.
      </p>
    </ul>
  </td>
</tr>
<tr>
  <td><br></td>
  <td><hr></td>
</tr>
<tr>
  <td><br></td>
  <td>
  <p>
    <b>Development Environments:</b>
    1) Linux with native Linux GNU toolchain, 2) Cygwin/MSYS with Cygwin GNU Cortex-M3 or 4 toolchain, 3) Cygwin/MSYS with Windows native GNU Cortex-M3 or M4 toolchain (CodeSourcery or devkitARM), or 4) Native Windows.  A DIY toolchain for Linux or Cygwin is provided by the NuttX
    <a href="http://sourceforge.net/projects/nuttx/files/buildroot/">buildroot</a> package.
    I use FreeScale's <i>CodeWarrior</i> IDE only to work with the JTAG debugger built into the Kinetis boards.
    I use the <i>Code Red</i> IDE with the some of the NXP parts and the <i>Atollic</i> toolchain with some of the STMicroelectronics parts.
  </p>
  </td>
</tr>

<tr>
  <td valign="top"><img height="20" width="20" src="favicon.ico"></td>
  <td bgcolor="#5eaee1">
    <a name="atmelavr"><b>Atmel AVR</b>.</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <b>SoC Robotics ATMega128</b>.
      This port of NuttX to the Amber Web Server from <a href="http://www.soc-robotics.com/index.htm">SoC Robotics</a>
      is partially completed.
      The Amber Web Server is based on an Atmel ATMega128.
    </p>
    <ul>
      <p>
       <b>STATUS:</b>
         Work on this port has stalled due to toolchain issues.  Complete, but untested
         code for this port appears in the NuttX 6.5 release.
      </p>
    </ul>
  </td>
</tr>
<tr>
  <td><br></td>
  <td><hr></td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <b>Micropendous 3 AT90USB64x</b> and <b>AT90USB6128x</b>.
      This port of NuttX to the Opendous Micropendous 3 board. The Micropendous3 is
      may be populated with an AT90USB646, 647, 1286, or 1287.  I have only the AT90USB647
      version for testing.  This version have very limited memory resources: 64K of
      FLASH and 4K of SRAM.
    </p>
    <ul>
      <p>
       <b>STATUS:</b>
         The basic port was released in NuttX-6.5.  This basic port consists only of
         a &quot;Hello, World!!&quot; example that demonstrates initialization of the OS,
         creation of a simple task, and serial console output.
      </p>
    </ul>
  </td>
</tr>
<tr>
  <td><br></td>
  <td><hr></td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <b>PJRC Teensy++ 2.0 AT90USB1286</b>.
      This is a port of NuttX to the PJRC Teensy++ 2.0 board.
      This board was developed by <a href="http://pjrc.com/teensy/">PJRC</a>.
      The Teensy++ 2.0 is based on an Atmel AT90USB1286 MCU.
    </p>
    <ul>
      <p>
       <b>STATUS:</b>
         The basic port was released in NuttX-6.5.  This basic port consists of
         a &quot;Hello, World!!&quot; example that demonstrates initialization of the OS,
         creation of a simple task, and serial console output as well as a somewhat
         simplified NuttShell (NSH) configuration (see the
         <a href="http://www.nuttx.org/Documentation/NuttShell.html">NSH User Guide</a>).
      </p>
      <p>
         An SPI driver and a USB device driver exist for the AT90USB as well
         as a USB mass storage configureation.  However, this configuration is not
         fully debugged as of the NuttX-6.5 release.
      </p>
    </ul>
  </td>
</tr>
<tr>
  <td><br></td>
  <td><hr></td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p><b>AVR-Specific Issues</b>.
      The basic AVR port is solid and biggest issue for using AVR is its tiny SRAM memory and its Harvard architecture.
      Because of the Harvard architecture, constant data that resides to flash is inaccessible using &quot;normal&quot; memory reads and writes (only SRAM data can be accessed &quot;normally&quot;).
      Special AVR instructions are available for accessing data in FLASH, but these have not been integrated into the normal, general purpose OS.
    </p>
    <p>
      Most NuttX test applications are console-oriented with lots of strings used for printf and debug output.
      These strings are all stored in SRAM now due to these data accessing issues and even the smallest console-oriented applications can quickly fill a 4-8K memory.
      So, in order for the AVR port to be useful, one of two things would need to be done:
    </p>
    <ol>
      <li>
        Don't use console applications that required lots of strings.
        The basic AVR port is solid and your typical deeply embedded application should work fine.
        Or,
      </li>
      <li>
        Create a special version of printf that knows how to access strings that reside in FLASH (or EEPROM).
      </li>
    </ol>
</tr>
<tr>
  <td><br></td>
  <td>
      <p>
        <b>Development Environments:</b>
        1) Linux with native Linux GNU toolchain, 2) Cygwin/MSYS with Cygwin GNU toolchain, 3) Cygwin/MSYS with Windows native toolchain, or 4) Native Windows. 
        All testing, however, has been performed using the NuttX DIY toolchain for Linux  or Cygwin is provided by the NuttX
        <a href="http://sourceforge.net/projects/nuttx/files/buildroot/">buildroot</a> package.
        As a result, that toolchain is recommended.
      </p>
  </td>
</tr>
<tr>
  <td><br></td>
  <td><br></td>
</tr>

<tr>
  <td valign="top"><img height="20" width="20" src="favicon.ico"></td>
  <td bgcolor="#5eaee1">
    <a name="atmelavr32"><b>Atmel AVR32</b>.</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <b>AV32DEV1</b>.
      This port uses the www.mcuzone.com AVRDEV1 board based on the Atmel AT32UC3B0256 MCU.
      This port requires a special GNU avr32 toolchain available from atmel.com website.
      This is a windows native toolchain and so can be used only under Cygwin on Windows.
    </p>
    <ul>
      <p>
       <b>STATUS:</b>
         This port is has completed all basic development, but there is more that needs to be done.
         All code is complete for the basic NuttX port including header files for all AT32UC3* peripherals.
         The untested AVR32 code was present in the 5.12 release of NuttX.
         Since then, the basic RTOS port has solidified:
      </p>
      <ul>
        <li>
          The port successfully passes the NuttX OS test (apps/examples/ostest).
        </li>
        <li>
          A NuttShell (NSH) configuration is in place (see the <a href="http://www.nuttx.org/Documentation/NuttShell.html">NSH User Guide</a>).
          Testing of that configuration has been postponed (because it got bumped by the Olimex LPC1766-STK port).
          Current Status: I think I have a hardware problem with my serial port setup.
          There is a good chance that the NSH port is complete and functional, but I am not yet able to demonstrate that.
          At present, I get nothing coming in the serial RXD line (probably because the pins are configured wrong or I have the MAX232 connected wrong).
        </li>
      </ul>
      <p>
        The basic, port (including the verified apps/examples/ostest configuration) was be released in NuttX-5.13.
        A complete port will include drivers for additional AVR32 UC3 devices -- like SPI and USB --- and will be available in a later release,
        time permitting.
      </p>
    </ul>
  </td>
</tr>
<tr>
  <td valign="top"><img height="20" width="20" src="favicon.ico"></td>
  <td bgcolor="#5eaee1">
    <a name="m68hcs12"><b>Freescale M68HCS12</b>.</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <b>MC9S12NE64</b>.
      Support for the MC9S12NE64 MCU and two boards are included:
    </p>
    <ul>
      <li>
        The Freescale DEMO9S12NE64 Evaluation Board, and
      </li>
      <li>
        The Future Electronics Group NE64 /PoE Badge board.
      </li>
    </ul>
    <p>
      Both use a GNU arm-nuttx-elf toolchain* under Linux or Cygwin.
      The NuttX <a href="http://sourceforge.net/projects/nuttx/files/buildroot/">buildroot</a> provides a properly patched GCC 3.4.4 toolchain that is highly optimized for the m9s12x family.
    </p>
    <ul>
      <p>
       <b>STATUS:</b>
         Coding is complete for the MC9S12NE64 and for the NE64 Badge board.
         However, testing has not yet begun due to issues with BDMs, Code Warrior, and
         the paging in the build process.
         Progress is slow, but I hope to see a fully verified MC9S12NE64 port in the near future.
      </p>
    </ul>
  </td>
</tr>
<tr>
  <td valign="top"><img height="20" width="20" src="favicon.ico"></td>
  <td bgcolor="#5eaee1">
    <a name="8052"><b>Intel 8052 Microcontroller</b>.</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <b>PJRC 87C52 Development Board</b>.
      This port uses the <a href="http://www.pjrc.com/">PJRC</a> 87C52 development system
      and the <a href="http://sdcc.sourceforge.net/">SDCC</a> toolchain under Linux or Cygwin.
    </p>
    <ul>
      <p>
       <b>STATUS:</b>
        This port is complete but not stable with timer interrupts enabled.
        There seems to be some issue when the stack pointer enters into the indirect IRAM
        address space during interrupt handling.
        This architecture has not been built in some time will likely have some compilation
        problems because of SDCC compiler differences.
      </p>
    </ul>
  </td>
</tr>
<tr>
  <td valign="top"><img height="20" width="20" src="favicon.ico"></td>
  <td bgcolor="#5eaee1">
    <a name="80x86"><b>Intel 80x86</b>.</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <b>QEMU/Bifferboard i486</b>.
      This port uses the <a href="http://wiki.qemu.org/Main_Page">QEMU</a> i486 and the native
      Linux, Cywgin, MinGW the GCC toolchain under Linux or Cygwin.
    </p>
    <ul>
      <p>
       <b>STATUS:</b>
         The basic port was code-complete in NuttX-5.19 and verifed in NuttX-6.0.
         The port was verified using the OS and NuttShell (NSH) examples under QEMU.
         The port is reported to be functional on the <a href="http://bifferos.bizhat.com">Bifferboard</a> as well.
         This is a great, stable starting point for anyone interest in fleshing out the x86 port!
      </p>
    </ul>
  </td>
</tr>
<tr>
  <td><br></td>
  <td><hr></td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <b>RGMP</b>.
      RGMP stands for RTOS and GPOS on Multi-Processor.
      RGMP is a project for  running GPOS and RTOS simultaneously on multi-processor platforms
      You can port your favorite RTOS to RGMP together with an unmodified Linux to form a hybrid operating system.
      This makes your application able to use both RTOS and GPOS features.
    </p>
    <p>
      See the <a href="http://rgmp.sourceforge.net/wiki/index.php/Main_Page">RGMP Wiki</a> for further information about RGMP.
    </p>
    <ul>
      <p>
       <b>STATUS:</b>
         This initial port of NuttX to RGMP was provided in NuttX-6.3.
         This initial RGP port provides only minimal driver support and does not use the native NuttX interrupt system.
         This is a great, stable starting point for anyone interest in working with NuttX under RGMP!
      </p>
    </ul>
  </td>
</tr>
<tr>
  <td valign="top"><img height="20" width="20" src="favicon.ico"></td>
  <td bgcolor="#5eaee1">
    <a name="pic32mips"><b>MicroChip PIC32 (MIPS)</b>.</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p><b>PIC32MX250F128D</b>.
      A port is in progress from the DTX1-4000L &quot;Mirtoo&quot; module from <a href="http://www.dimitech.com/" >Dimitech</a>.
      This module uses MicroChip PIC32MX250F128D and the Dimitech DTX1-4000L EV-kit1 V2.
      See the <a href="http://www.dimitech.com/">Dimitech</a> website for further information.
    </p>
    <ul>
      <p>
        <b>STATUS:</b>
        The basic port is code complete.
        Two configurations are available:
        (1) An OS test configuration and a (2) configuration that support the NuttShell (NSH).
        The OS test configuration is fully functional and proves that we have a basically healthy NuttX port to the Mirtoo.
        The NSH configuration includes support for a serial console and for the SST25 serial FLASH and the PGA117 amplifier/multiplexer on board the module.
        The NSH configuration is set up to use the NuttX wear-leveling FLASH file system (NXFFS).
        The PGA117, however, is not yet fully integrated to support ADC sampling.
        See the <a href="http://www.nuttx.org/Documentation/NuttShell.html">NSH User Guide</a> for further information about NSH.
        The first verified port to the Mirtoo module was available with the NuttX 6.20 release.
      </p>
    </ul>
  </td>
</tr>
<tr>
  <td><br></td>
  <td><hr></td>
</tr>
<tr>
  <td><br></td>
  <td>
   <p><b>PIC32MX460F512L</b>.  There one two board ports using this chip:</p>
   <ul>
    <li><b>PIC32MX Board from PCB Logic Design Co</b>.
      This port is for the PIC32MX board from PCB Logic Design Co. and used the PIC32MX460F512L.
      The board is a very simple -- little more than a carrier for the PIC32 MCU plus voltage regulation, debug interface, and an OTG connector.
    </li>
    <p>
      <b>STATUS:</b>
      The basic port is code complete and fully verified in NuttX 6.13.
      Available configurations include the OS test and the NuttShell (NSH - see the <a href="http://www.nuttx.org/Documentation/NuttShell.html">NSH User Guide</a>).
    </p>
    <li><b>UBW32 Board from Sparkfun</b>
      This is the port to the Sparkfun UBW32 board.
      This port uses the <a href="http://www.sparkfun.com/products/8971">original v2.5</a> board which is based on the MicroChip PIC32MX460F512L.
      This older version has been replaced with this <a href="http://www.sparkfun.com/products/9713">newer board</a>.
      See also the <a href="http://www.schmalzhaus.com/UBW32/">UBW32</a> web site.
    </li>
    <p>
      <b>STATUS:</b>
      The basic port is code complete and fully verified in NuttX 6.18.
      Available configurations include the OS test and the NuttShell (NSH - see the <a href="http://www.nuttx.org/Documentation/NuttShell.html">NSH User Guide</a>).
      USB has not yet been fully tested but on first pass appears to be functional.
    </p>
  </ul>
  </td>
</tr>
<tr>
  <td><br></td>
  <td><hr></td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <b>PIC32MX440F512H</b>.
        This port uses the &quot;Advanced USB Storage Demo Board,&quot; Model DB-DP11215, from <a href="http://www.sureelectronics.net">Sure Electronics</a>.
        This board features the MicroChip PIC32MX440F512H.
        See the <a href="http://www.sureelectronics.net/goods.php?id=1168">Sure website</a> for further information about the DB-DP11215 board.
        (I believe that that the DB-DP11215 may be obsoleted now but replaced with the very similar, DB-DP11212.
        The DB-DP11212 board differs, I believe, only in its serial port configuration.)
    </p>
    <ul>
      <p>
       <b>STATUS:</b>
       This NuttX port is code complete and has considerable test testing.
       The port for this board was completed in NuttX 6.11, but still required a few bug fixes before it will be ready for prime time.
       The fully verified port first appeared in NuttX 6.13.
       Available configurations include the OS test and the NuttShell (NSH - see the <a href="http://www.nuttx.org/Documentation/NuttShell.html">NSH User Guide</a>).
       An untested USB device-side driver is available in the source tree.
       A more complete port would include support of the USB OTG port and of the LCD display on this board.
       Those drivers are not yet available as of this writing.
       </p>
    </ul>
  </td>
</tr>
<tr>
  <td><br></td>
  <td><hr></td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <b>PIC32MX795F512L</b>.
        There one two board ports using this chip:
    </p>
    <ul>
      <li><b>Microchip PIC32 Ethernet Starter Kit</b>.
         This port uses the Microchip PIC32 Ethernet Starter Kit (DM320004) with the Expansion I/O board.
         See the <a href="http://ww.microchip.com">Microchip website</a> for further information.
      </li>
      <p>
       <b>STATUS:</b>
         This port was started and then shelved for some time until I received the Expansion I/O board.
         The basic Starter Kit (even with the Multimedia Expansion Board, MEB, DM320005)) has no serial port and most NuttX test configurations depend heavily on console output.
      </p>
      <p>
         Verified configurations for the OS test and the NuttShel (NSH) appeared in NuttX-6.16.
         Board support includes a verified USB (device-side) driver.
         Also included are a a verified Ethernet driver, a partially verified USB device controller driver, and an unverifed SPI driver.
         Stay tuned for updates.
      </p>
     <li><b>Mikroelektronika PIC32MX7 Mulitmedia Board (MMB)</b>.
        A port has been completed for the  Mikroelektronika PIC32MX7 Multimedia Board (MMB).
        See http://www.mikroe.com/ for further information about this board.
      </li>
      <p>
       <b>STATUS:</b>
         Two verified configurations are available:
         (1) The basic OS test configuration that verfies the correctness port of NuttX, and (2) an extensive <a href="NuttShell.html">NuttShell (NSH)</a> configuration.
         The NSH configuration includes:
         (1) Full network support,
         (2) Verified SPI driver,
         (3) SPI-based SD Card support,
         (4) USB device support (including configuration options for the USB mass storage device and the CDC/ACM serial class), and
         (5) Support for the MIO873QT2 LCD on the PIC32MX7 MMB.
       </p>
       </p>
         The PIC32MX7 MMB's touchscreen is connected directly to the MCU via ADC pins.
         A touchscreen driver has been developed using the PIC32's ADC capabilities and can be enabled in the NSH configuration.
         However, additional verification and tuning of this driver is required.
         Further display/touchscreen verification would require C++ support (for NxWidgets and NxWM).
         Since I there is no PIC32 C++ is the free version of the MPLAB C32 toolchain, further graphics development is stalled.
      </p>
    </ul>
  </td>
</tr>
<tr>
  <td><br></td>
  <td><hr></td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <b>Development Environment:</b>
      These ports uses either:
    </p>
    <ol>
      <li>
        The <i>LITE</i> version of the PIC32MX toolchain available
        for download from the <a href="http://www.microchip.com">MicroChip</a> website, or
      </li>
      <li>
        The Pinguino MIPS ELF toolchain avaiable from the Pinquino <a href="http://code.google.com/p/pinguino32/downloads/list">website</a>.
      </li>
    </ol>
  </td>
</tr>
<tr>
  <td><br></td>
  <td><br></td>
</tr>
<tr>
  <td valign="top"><img height="20" width="20" src="favicon.ico"></td>
  <td bgcolor="#5eaee1">
    <a name="superh"><b>Renesas/Hitachi SuperH</b>.</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <b>SH-1 SH7032</b>.
      This port uses the Hitachi SH-1 Low-Cost Evaluation Board (SH1_LCEVB1), US7032EVB,
      with a GNU ELF toolchain* under Linux or Cygwin.
    </p>
    <ul>
      <p>
       <b>STATUS:</b>
        This port is available as of release 0.3.18 of NuttX.  The port is basically complete
        and many examples run correctly.  However, there are remaining instabilities that
        make the port un-usable.  The nature of these is not understood; the behavior is
        that certain SH-1 instructions stop working as advertised.  This could be a silicon
        problem, some pipeline issue that is not handled properly by the gcc 3.4.5 toolchain
        (which has very limit SH-1 support to begin with), or perhaps with the CMON debugger.
        At any rate, I have exhausted all of the energy that I am willing to put into this cool
        old processor for the time being.
      </p>
    </ul>
  </td>
</tr>
<tr>
  <td valign="top"><img height="20" width="20" src="favicon.ico"></td>
  <td bgcolor="#5eaee1">
    <a name="m16c"><b>Renesas M16C/26</b>.</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <b>Renesas M16C/26 Microcontroller</b>.
      This port uses the Renesas SKP16C26 Starter kit and the GNU M32C toolchain. 
      The development environment is either Linux or Cygwin under WinXP.
    </p>
    <ul>
      <p>
        <b>STATUS:</b>
        Initial source files released in nuttx-0.4.2.
        At this point, the port has not been integrated;    the target cannot be built
        because the GNU <code>m16c-nuttx-elf-ld</code> link fails with  the following message:
      </p>
      <ul>
      <code>m32c-nuttx-elf-ld: BFD (GNU Binutils) 2.19 assertion fail /home/Owner/projects/nuttx/buildroot/toolchain_build_m32c/binutils-2.19/bfd/elf32-m32c.c:482</code>
      </ul>
      <p>Where the reference line is:</p>
      <ul><pre>
/* If the symbol is out of range for a 16-bit address,
   we must have allocated a plt entry.  */
BFD_ASSERT (*plt_offset != (bfd_vma) -1);
</pre></ul>
      <p>
        No workaround is known at this time.  This is a show stopper for M16C for
        the time being.
      </p>
    </ul>
  </td>
</tr>
<tr>
  <td valign="top"><img height="20" width="20" src="favicon.ico"></td>
  <td bgcolor="#5eaee1">
    <a name="zilogz16f"><b>Zilog Z16F</b>.</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <b>Zilog z16f Microcontroller</b>.
      This port use the Zilog z16f2800100zcog development kit and the Zilog
      ZDS-II Windows command line tools.
      The development environment is either Windows native or Cygwin under Windows.
    </p>
    <ul>
      <p>
        <b>STATUS:</b>
        The initial release of support for the z16f was made available in NuttX version 0.3.7.
      </p>
    </ul>
  </td>
</tr>
<tr>
  <td valign="top"><img height="20" width="20" src="favicon.ico"></td>
  <td bgcolor="#5eaee1">
    <a name="zilogez80acclaim"><b>Zilog eZ80 Acclaim!</b>.</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <b>Zilog eZ80Acclaim! Microcontroller</b>.
      There are two eZ80Acclaim! ports:
    </p>
    <ul>
      <li>One uses the ZiLOG ez80f0910200kitg development kit, and
      <li>The other uses the ZiLOG ez80f0910200zcog-d development kit.
    </ul>
    <p>
      Both boards are based on the eZ80F091 part and both use the Zilog ZDS-II
      Windows command line tools.
      The development environment is either Windows native or Cygwin under Windows.
    </p>
    <ul>
      <p>
        <b>STATUS:</b>
        Integration and testing of NuttX on the  ZiLOG ez80f0910200zcog-d is complete.
        The first integrated version was released in NuttX version 0.4.2 (with important early bugfixes
        in 0.4.3 and 0.4.4).
        As of this writing, that port provides basic board support with a serial console, SPI, and eZ80F91 EMAC driver.
      </p>
    </ul>
  </td>
</tr>
<tr>
  <td valign="top"><img height="20" width="20" src="favicon.ico"></td>
  <td bgcolor="#5eaee1">
    <a name="zilogz8encore"><b>Zilog Z8Encore!</b>.</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <b>Zilog Z8Encore! Microcontroller</b>.
      This port uses the either:
    </p>
    <ul>
      <li>Zilog z8encore000zco development kit, Z8F6403 part, or</li>
      <li>Zilog z8f64200100kit development kit, Z8F6423 part</li>
    </ul>
    <p>
      and the Zilog ZDS-II Windows command line tools.
      The development environment is either Windows native or Cygwin under Windows.
    </p>
    <ul>
       <p>
         <b>STATUS:</b>
         This release has been verified only on the ZiLOG ZDS-II Z8Encore! chip simulation
         as of nuttx-0.3.9.
       </p>
     <ul>
  </td>
</tr>
<tr>
  <td valign="top"><img height="20" width="20" src="favicon.ico"></td>
  <td bgcolor="#5eaee1">
    <a name="zilogz180"><b>Zilog Z180</b>.</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <b>P112</b>.
      The P112 is a hobbyist single board computer based on a 16MHz Z80182 with up to 1MB of memory, serial,
parallel and diskette IO, and realtime clock, in a 3.5-inch drive form factor..
      The P112 computer originated as a commercial product of &quot;D-X Designs Pty Ltd&quot[ of Australia.
    </p>
    </p>
      Dave Brooks was successfully funded through Kickstarter for and another run of P112 boards in November of 2012.
      In addition Terry Gulczynski makes additional P112 derivative hobbyist home brew computers.
    </p>
    <ul>
      <p>
       <b>STATUS:</b>
       Most of the NuttX is in port for both the Z80182 and for the P112 board.
       Boards from Kickstarter project will not be available, however, until the first quarter of 2013.
       So it will be some time before this port is verified on hardware.
      </p>
    <ul>
  </td>
</tr>
<tr>
  <td valign="top"><img height="20" width="20" src="favicon.ico"></td>
  <td bgcolor="#5eaee1">
    <a name="zilogz80"><b>Zilog Z80</b>.</a>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <b>Z80 Instruction Set Simulator</b>.
      This port uses the <a href="http://sdcc.sourceforge.net/">SDCC</a> toolchain
      under Linux or Cygwin (verified using version 2.6.0).
      This port has been verified using only a Z80 instruction simulator.
      That simulator can be found in the NuttX GIT
      <a href="http://sourceforge.net/p/nuttx/git/ci/master/tree/misc/sims/z80sim/">here</a>.
    </p>
    <ul>
      <p>
       <b>STATUS:</b>
        This port is complete and stable to the extent that it can be tested
        using an instruction set simulator.
      </p>
    <ul>
  </td>
</tr>
<tr>
  <td><br></td>
  <td><hr></td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <b>XTRS: TRS-80 Model I/III/4/4P Emulator for Unix</b>.
      A very similar Z80 port is available for <a href="http://www.tim-mann.org/xtrs.html">XTRS</a>,
      the TRS-80 Model I/III/4/4P Emulator for Unix.
      That port also uses the <a href="http://sdcc.sourceforge.net/">SDCC</a> toolchain
      under Linux or Cygwin (verified using version 2.6.0).
    </p>
    <ul>
      <p>
       <b>STATUS:</b>
       Basically the same as for the Z80 instruction set simulator.
       This port was contributed by Jacques Pelletier.
      </p>
    <ul>
  </td>
</tr>
</table></center>

<blockquote>* A highly modified <a href="http://buildroot.uclibc.org/">buildroot</a>
is available that may be used to build a NuttX-compatible ELF toolchain under
Linux or Cygwin.  Configurations are available in that buildroot to support ARM, Cortex-M3,
avr, m68k, m68hc11, m68hc12, m9s12, blackfin, m32c, h8, and SuperH ports.</blockquote>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="environments"><h1>Development Environments</h1></a>
  </td>
  </tr>
</table>

<center><table width="90%">
<tr>
  <td valign="top"><img height="20" width="20" src="favicon.ico"></td>
  <td bgcolor="#5eaee1">
    <b>Linux + GNU <code>make</code> + GCC/binutils for Linux</b>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      The is the most natural development environment for NuttX.
      Any version of the GCC/binutils toolchain may be used.
      There is a  highly modified <a href="http://buildroot.uclibc.org/">buildroot</a>
      available for download from the
      <a href="http://sourceforge.net/projects/nuttx/files/">NuttX SourceForge</a>
      page.
      This download may be used to build a NuttX-compatible ELF toolchain under Linux or Cygwin.
      That toolchain will support ARM, m68k, m68hc11, m68hc12, and SuperH ports.
      The buildroot GIT may be accessed in the 
      <a href="http://sourceforge.net/p/nuttx/git/ci/master/tree/misc/buildroot/">NuttX GIT</a>.
    </p>
   </td>
</tr>

<tr>
  <td valign="top"><img height="20" width="20" src="favicon.ico"></td>
  <td bgcolor="#5eaee1">
    <b>Linux + GNU <code>make</code> + SDCC for Linux</b>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      Also very usable is the Linux environment using the 
      <a href="http://sdcc.sourceforge.net/">SDCC</a> compiler.
      The SDCC compiler provides support for the 8051/2, z80, hc08, and other microcontrollers.
      The SDCC-based logic is less well exercised and you will likely find some compilation
      issues if you use parts of NuttX with SDCC that have not been well-tested.
    </p>
   </td>
</tr>

<tr>
  <td valign="top"><img height="20" width="20" src="favicon.ico"></td>
  <td bgcolor="#5eaee1">
    <b>Windows with Cygwin + GNU <code>make</code> + GCC/binutils (custom built under Cygwin)</b>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      This combination works well too.
      It works just as well as the native Linux environment except that compilation and build times are a little longer.
      The custom NuttX <a href="http://sourceforge.net/projects/nuttx/files/buildroot/">buildroot</a> referenced above may be build in the Cygwin environment as well.
    </p>
  </td>
</tr>

<tr>
  <td valign="top"><img height="20" width="20" src="favicon.ico"></td>
  <td bgcolor="#5eaee1">
    <b>Windows with Cygwin + GNU <code>make</code> + SDCC (custom built under Cygwin)</b>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
       I have never tried this combination, but it would probably work just fine.
    </p>
  </td>
</tr>

<tr>
  <td valign="top"><img height="20" width="20" src="favicon.ico"></td>
  <td bgcolor="#5eaee1">
    <b>Windows with Cygwin + GNU <code>make</code> + Windows Native Toolchain</b>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      This is a tougher environment.
      In this case, the Windows native toolchain is unaware of the
      Cygwin <i>sandbox</i> and, instead, operates in the native Windows environment.
      The primary difficulties with this are:
    </p>
    <ul>
      <li>
        <b>Paths</b>.
        Full paths for the native toolchain must follow Windows standards.
        For example, the path <code>/home/my\ name/nuttx/include</code> my have to be
        converted to something like <code>'C:\cygwin\home\my name\nuttx\include'</code>
        to be usable by the toolchain.
      </li>
      <p>
        Fortunately, this conversion is done simply using the <code>cygpath</code> utility.
      </p>
      <li>
        <b>Symbolic Links</b>
        NuttX depends on symbolic links to install platform-specific directories in the build system.
        On Linux, true symbolic links are used.
        On Cygwin, emulated symbolic links are used.
        Unfortunately, for native Windows applications that operate outside of the
        Cygwin <i>sandbox</i>, these symbolic links cannot be used.
      </li>
      <p>
        The NuttX make system works around this limitation by copying the platform
        specific directories in place.
        These copied directories make work a little more complex, but otherwise work well.
      </p>
      <p><small>
        NOTE: In this environment, it should be possible to use the NTFS <code>mklink</code> command to create links.
        This should only require a minor modification to the build scripts (see <code>tools/copydir.sh</code> script).
      </small></p>
      <li>
        <b>Dependencies</b>
        NuttX uses the GCC compiler's <code>-M</code> option to generate make dependencies.  These
        dependencies are retained in files called <code>Make.deps</code> throughout the system.
        For compilers other than GCC, there is no support for making dependencies in this way.
        For Windows native GCC compilers, the generated dependencies are windows paths and not
        directly usable in the Cygwin make.  By default, dependencies are surpressed for these
        compilers as well.
      </li>
      <p><small>
        NOTE: dependencies are suppress by setting the make variable <code>MKDEPS</code> to point
        to the do-nothing dependency script, <code>tools/mknulldeps.sh</code>.
      </small></p>
    </ul>
    <p>
      <b>Supported Windows Native Toolchains</b>.
      At present, the following Windows native toolchains are in use:
      <ol>
        <li>GCC built for Windows (such as CodeSourcery, Atollic, devkitARM, etc.),</li>
        <li>SDCC built for Windows,</li>
        <li> the ZiLOG XDS-II toolchain for Z16F, z8Encore, and eZ80Acclaim parts.</li>
      </ol>
    </p>
  </td>
</tr>

<tr>
  <td valign="top"><img height="20" width="20" src="favicon.ico"></td>
  <td bgcolor="#5eaee1">
    <b>Windows Native (<code>CMD.exe</code>) + GNUWin32 (including GNU <code>make</code>) + MinGW Host GCC compiler + Windows Native Toolchain</b>
  </td>
</tr>
  <td><br></td>
  <td>
    <p>
      Build support has been added to support building natively in a Windows console rather than in a POSIX-like environment.
    </p>
    <p>
      This build:
    </p>
    <ol>
      <li>Uses all Windows style paths</li>
      <li>Uses primarily Windows batch commands from cmd.exe, with</li>
      <li>A few extensions from GNUWin32</li>
    </ol>
    <p>
      This capability first appeared in NuttX-6.24 and should still be considered a work in progress because: (1) it has not been verfied on all targets and tools, and (2) still lacks some of the creature-comforts of the more mature environments.
      The windows native build logic initiatiated if <code>CONFIG_WINDOWS_NATIVE=y</code> is defined in the NuttX configuration file:
    </p>
    <p>
      At present, this build environment also requires:
    </p>
    <ul>
      <li>
        <b>Windows Console</b>.
        The build must be performed in a Windows console window.
        This may be using the standard <code>CMD.exe</code> terminal that comes with Windows.
        I prefer the ConEmu terminal which can be downloaded from:
        http://code.google.com/p/conemu-maximus5/
      </li>
      <li>
        <b>GNUWin32</b>.
        The build still relies on some Unix-like commands.
        I usethe GNUWin32 tools that can be downloaded from http://gnuwin32.sourceforge.net/.
        See the top-level <code>nuttx/README.txt</code> file for some download, build, and installation notes.
      </li>
      <li>
        <b>MinGW-GCC</b>.
        MinGW-GCC is used to compiler the C tools in the <code>nuttx/tools</code> directory that are neede by the build.
        MinGW-GCC can be downloaded from http://www.mingw.org/.
        If you are using GNUWin32, then it is recommendedthe you not install the optional MSYS components as there may be conflicts.
      </li>
  </td>
</tr>

<tr>
  <td valign="top"><img height="20" width="20" src="favicon.ico"></td>
  <td bgcolor="#5eaee1">
    <b>Wine + GNU <code>make</code> + Windows Native Toolchain</b>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      I've never tried this one, but I off the following reported by an ez80 user using the ZiLOG ZDS-II Windows-native toolchain:
    </p>
    <blockquote>
      <p>
         &quot;I've installed ZDS-II 5.1.1 (IDE for ez80-based boards) on wine (windows emulator for UNIX) and to my surprise, not many changes were needed to make GIT snapshot of NuttX buildable...
         I've tried nsh profile and build process completed successfully.
         One remark is necessary: NuttX makefiles for ez80 are referencing <code>cygpath</code> utility.
         Wine provides similar thing called <code>winepath</code> which is compatible and offers compatible syntax.
         To use that, <code>winepath</code> (which itself is a shell script) has to be copied as <code>cygpath</code> somewhere in <code>$PATH</code>, and edited as in following patch:
       </p>
       <ul><pre>
# diff -u `which winepath` `which cygpath`
--- /usr/bin/winepath 2011-05-02 16:00:40.000000000 +0200
+++ /usr/bin/cygpath 2011-06-22 20:57:27.199351255 +0200
@@ -20,7 +20,7 @@
#

# determine the app Winelib library name
-appname=`basename "$0" .exe`.exe
+appname=winepath.exe

# first try explicit WINELOADER
if [ -x "$WINELOADER" ]; then exec "$WINELOADER" "$appname" "$@"; fi
</pre></ul>
      <p>
        &quot;Better solution would be replacing all <code>cygpath</code> references in  <code>Makefiles </code> with  <code>$(CONVPATH)</code> (or  <code>${CONVPATH}</code> in shell scripts) and setting <code>CONVPATH</code> to  <code>cygpath</code> or  <code>winepath</code> regarding to currently used environment.
      </p>
    </blockquote>
  </td>
</tr>

<tr>
  <td valign="top"><img height="20" width="20" src="favicon.ico"></td>
  <td bgcolor="#5eaee1">
    <b>Other Environments?</b>
  </td>
</tr>
<tr>
  <td><br></td>
  <td>
    <p>
      <b>Environment Dependencies</b>.
      The primary environmental dependency of NuttX are (1) GNU make,
      (2) bash scripting, and (3) Linux utilities (such as cat, sed, etc.).
      If you have other platforms that support GNU make or make
      utilities that are compatible with GNU make, then it is very
      likely that NuttX would work in that environment as well (with some
      porting effort). If GNU make is not supported, then some significant
      modification of the Make system would be required.
    </p>
    <p>
      <b>MSYS</b>.
      I have not used MSYS but what I gather from talking with NuttX users is that MSYS can be used as an alternative to Cygwin in any of the above Cygwin environments.
      This is not surprising since MSYS is based on an older version of Cygwin (cygwin-1.3).
      MSYS has been modified, however, to interoperate in the Windows environment better than Cygwin and that may be of value to some users.
    </p>
    <p>
      MSYS, however, cannot be used with the native Windows NuttX build because it will invoke the MSYS bash shell instead of the <code>CMD.exe</code> shell.
      Use GNUWin32 in the native Windows build envionment.
    </p>
  </td>
</tr>
</table></center>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="footprint"><h1>Memory Footprint</h1></a>
  </td>
  </tr>
</table>

<ul>
<p><b>C5471 (ARM7)</b>
  The build for this ARM7 target that includes most of the OS features and
  a broad range of OS tests.  The size of this executable as given by the
  Linux <tt>size</tt> command is (3/9/07):
</p>
<pre>
   text    data     bss     dec     hex filename
  53272     428    3568   57268    dfb4 nuttx
</pre>
<p><b>DM320 (ARM9)</b>
  This build for the ARM9 target includes a significant subset of OS
  features, a filesystem, Ethernet driver, full TCP/IP, UDP and (minimal)
  ICMP stacks (via uIP) and a small network test application: (11/8/07,
  configuration netconfig, apps/examples/nettest)
</p>
<pre>
   text    data     bss     dec     hex filename
  49472     296    3972   53740    d1ec nuttx
</pre>
<p>
  Another build for the ARM9 target includes a minimal OS feature
  set, Ethernet driver, full TCP/IP and (minimal) ICMP stacks, and
  a small webserver: (11/20/07, configuration uipconfig, apps/examples/uip)
</p>
<pre>
   text    data     bss     dec     hex filename
  52040      72    4148   56260    dbc4 nuttx
</pre>
<p><b>87C52</b>
  A reduced functionality OS test for the 8052 target requires only
  about 18-19K:
</p>
<pre>
Stack starts at: 0x21 (sp set to 0x20) with 223 bytes available.

Other memory:
   Name             Start    End      Size     Max
   ---------------- -------- -------- -------- --------
   PAGED EXT. RAM                         0      256
   EXTERNAL RAM     0x0100   0x02fd     510     7936
   ROM/EPROM/FLASH  0x2100   0x6e55   19798    24384
</pre>
</ul>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="licensing"><h1>Licensing</h1></a>
  </td>
  </tr>
</table>

<ul>
<p>
  NuttX is available under the highly permissive
  <a href="http://en.wikipedia.org/wiki/BSD_license">BSD license</a>.
  Other than some fine print that you agree to respect the copyright
  you should feel absolutely free to use NuttX in any environment and
  without any concern for jeopardizing any proprietary software that
  you may link with it.
</p>
</ul>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="history"><h1>Release History</h1></a>
  </td>
  </tr>
</table>

<ul>
<p>
   ChangeLog snapshots associated with the previous, current, and future release are available below.
</p>
</ul>

<center><table width ="80%">
<tr>
  <td valign="top" width="22"><img height="20" width="20" src="favicon.ico"></td>
   <td>
      <a href="ChangeLog.txt">Change logs for previous NuttX releases</a><br>
   </td>
</tr>
<tr>
  <td valign="top" width="22"><img height="20" width="20" src="favicon.ico"></td>
   <td>
      <a href="#currentrelease">ChangeLog for the current NuttX releases</a><br>
   </td>
</tr>
<tr>
  <td valign="top" width="22"><img height="20" width="20" src="favicon.ico"></td>
   <td>
      <a href="#pendingchanges">Unreleased changes</a>
   </td>
</tr>
</table></center>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="currentrelease">ChangeLog for the Current Release</a>
  </td>
  </tr>
</table>

<ul><pre>
nuttx-6.26 2013-05-15 Gregory Nutt &lt;gnutt@nuttx.org&gt;

    * drivers/serial/serial.c:  Correct some race conditions when checking
      for disconnection of a removable serial device.
    * sched/task_posixspawn.c, task_spawn.c, task_spawnparms.c and
      spawn_internal.h:  Create new interface task_spawn() that is
      like posix_spawn(), but uses entry point addresses like
      task_create().
    * Corrected all argv[] arguments. Should be char * const *, not
      const char **.
    * sched/pthread* and include/nuttx/sched: Move pthread join data
      and pthread key calculation data into the &quot;task group&quot; structure.
    * sched/atexit.c, on_exit.c, task_exithook.c and include/nuttx/sched.h:
      Move atexit and on_exit data structures to task group.  These
      callbacks are only issued now when the final member of the task
      group exits.
    * sched/waitpid.c, task_exithook.c and include/nuttx/sched.h:
      Move waitpid data data structures to task group.  Callers of
      of waitpid() are now only awakened whent he final thread of the
      task group exits.
    * sched/mq_descreate.c, mq_open.c, mq_remove.c, group_leave.c, and
      include/nuttx/sched.h:  Move list of opened message queues to
      the task group structures.  Now all message queues opened by
      members of the group are closed when the last member of the group
      exits.
    * includes/nuttx/sched.h and Lots of files:  Change name of _TCB to
      struct tcb_s so that (1) it is consitent with other NuttX naming and
      so that (2) the naming can handle some upcoming changes.
    * includes/nuttx/sched.h and sched/:  There are three TCB structures:
      struct tcb_s is a generic common version, struct task_tcb_s is a
      version for tasks and kernel threads and pthread_tcb_s is a version
      for pthreads.  By dividing the TCB structure into these variants,
      pthreads do not have to be burdened by task-specific data structures
      (and vice versa).
    * sched/task_exithook.c adn group_create.c:  Fix an error, the
      task within the task group may exit early leaving a pthread to
      exit the task group last.  In this case, we need to remember the
      the PID of the main task in the task group and use that PID for
      signalling SIGCHILD to the parent task group.
    * included/nuttx/sched.h and sched/sig*.c:  Numerous changes to the
      signal deliver logic so that the delivery of signals to threads
      within a task group will be compliant with delivery of signals
      to threads within a POSIX process.
    * sched/mq_recover.c and task_exithook.c:  Add logic to handle the
      case where a task is deleted (or pthread canceled) while it is
      waiting on a message queue.  task_delete() and pthread_cancel()
      are dangerous interfaces.  This is only one feeble recover measure
      of *many* that would be needed to do this safely.
    * sched/group_killchildren.c, task_recover.c, group_foreachchild.c,
      sched/restart.c, sched/task_delete.c, and others:  Beef up logic
      to better support task deletion and pthread cancellation.  Needed
      to pass need OS test case for task_restart().
    * sched/include/sched.h and all timed functions in sched/:  Move
      timer from local variables to TCB.  This is needed so that if a
      task is canceled or restarted while it is waiting for a timed
      event, we can gracefully recover.  We can't let the timer expire
      after the task has been deleted.
    * arch/arm/include/stm32 and arch/arm/src/stm32:  Add support for
      the STM32 F3 family (still missing some things).
    * configs/stm32f3discovery:  This will (eventually) be support for
      the STM32F3Discovery board.
    * STM32 F3 and STM32F3Discovery port is complete a ready for test.
    * arch/arm/src/lpc17xx: Add support for the Cortex-M4 FPU and
      Mikes &quot;common vector&quot; logic.  The LPC1788 is going to need
      these things.
    * arch/arm/src/stm32/stm32_spi.c:  Fix SPI DMA logic that does
      not work if sem_wait() is interrupt by a signal.  From Petteri
      Aimonen.
    * drivers/input/max11802.c: MAX11802: Fix a timing bug that
      corrupted coordinates.  From Petteri Aimonen.
    * drivers/mmcsd/mmcsd_spi.c:  Use SPI locking so that MMC/SD can
      exist on the same bus as other SPI devices.  From Petteri
      Aimonen.
    * graphics/nxfonts/nxfonts_sans17x22.h: Small mod to hyphen in
      sans17x22 font.  The hyphen did not have any space on its sides.
      This caused it to run together with other characters so that for
      example &quot;+-&quot; would look weird. From Petteri Aimonen.
    * mm/mm_mallinfo.c:  Take MM semaphore in mm_mallinfo. From Petteri
      Aimonen.
    * configs/stm32f3discovery/nsh/defconfig:  Disable SPI.  It is not
      used.
    * drivers/mtd/sst39vf:  Add a driver for the SST29VF NOR FLASH parts.
    * sched/os_start.c:  Add an additional call-out to support board-
      specific driver initialization during the start phase:  If
      CONFIG_BOARD_INITIALIZE is defined, then an additioinal
      initialization function called board_initialize() will be called
      just after up_initialize() is called and just before the initial
      application is started.
    * arch/arm/src/stm32/stm32_otgfsdev.c, drivers/usbdev/usbdev_trprintf.c,
      and include/nuttx/usb/usbdev_trace.h:  Add logic to support decoding
      of device-specific trace events to make the trace ouput more readable.
      From Petteri Aimonen.
    * arch/arm/src/stm32/stm32_otgfsdev.c:  Need to manually set CNAK in
      the case where we are waiting for a SETUP command with DATA.  Otherwise,
      the core may NAK further transactions.  From Petteri Aimonen.
    * arch/arm/src/stm32/stm32_otgfsdev.c: Add logic to prevent premature
      to IDLE state.  This change (plus the previous) was necessary to get
      the CDC/ACM driver working the certain STM32 F4 hardware (but not others).
      These changes appear to prevent certain race conditions that may or may
      not cause USB problems.  From Petteri Aimonen.
    * arch/arm/include/armv6-m and arch/arm/src/armv6-m: First cut at support
      for the Cortex-M0
    * configs/nutiny-nuc120, arch/arm/include/nu1xx, and arch/arm/src/nuc1xx:
      Support for Nuvoton NuTiny NUC120.
    * 2013-02-22:  the Cortex-M0, NuvoTron NUC1xx, and NuTiny-SDK-NUC120 port
      is code complete and ready for testing.
    * configs/ekk-lm3s9b96/ostest and nsh:  All EKK-LM3S9B96 configurations
      converted to use the mconf configuration tool.
    * configs/zkit-arm-1769:  Add support for Zilogic System's ARM development
      Kit, ZKIT-ARM-1769.  From Rashid.
    * configs/zkit-arm-1769/hello:  Add a &quot;Hello, World!&quot; configuration for
      the KBIT-ARM-1769 board.  From Rashid.
    * configs/zkit-arm-1769/thttpd:  Add a THTTPD configuration for the
      KBIT-ARM-1769 board.  From Rashid.
    * 2013-02-27: All configurations for the Cortex-M0 NuTINY-SDK-NUC120
      appear to be functional and stable.
    * configs/zkit-arm-1769/nsh:  Add an NSH configuration for the
      KBIT-ARM-1769 board.  From Rashid.
    * arch/arm/src/stm32/stm32_otgfsdev.c:  Fixes from Petterri Aimonen
      related to corner cases that can cause infinite interrupts.
    * drivers/usbdev/usbmsc_scsi.c:  Change to allow the full name in the
      USB descriptor but a truncated, 8-byte name in the SCSI field.
      From Petteri Aimonen.
    * arch/arm/src/stm32/stm32_spi.c: Need to clear error flags to prevent
      corruption of subsequent transfers.  Also, bit count should not be
      changed while the SPI peripheral is enabled.  From Petteri Aimonen.
    * drivers/mmcsd/mmcsd_spi.c:  When bus is shared, the speed has to be
      set every time.  Also SD cards require a few dummy clocks to react
      into CS release.  From Petteri Aimonen.
    * configs/lm4f120-launchpad: In initial configuration for testing
      the LM4F120 LaunchPad port.  This is to support testing only and
      is not yet a functional board port (as of 2013-03-01).
    * arch/arm/include/lm/lm4f_irq.h and arch/arm/src/lm/chip/lm4f_vector.h:
      Add interrupt vector/IRQ number definitions for the LM4F120.
    * arch/arm/src/stm32f20xxx_dma.c and stm32f40xxx_dma.c:  Fix a typo
      in assigned base register addresses for each DMA channel.  From
      Yan T.
    * Several build fixes from Mike Smith were incorporated.  These were
      mostly compilation errors introduced into the system because of the
      large number of recent changes with broad scope (2013-03-04).
    * configs/zkit-arm-17969/src/up_can.c:  Add CAN support to the
      Zilogics Technologies ZKIT-ARM-1769 board (From Rashid Fatah, (2013-03-04)).
    * arch/arm/src/lpc17/lpc17*_clockconfig.c:  The WaveShare Open1788
      board now boots and passes the OS test.  This is the work of
      Rommel Marcelo (2013-03-04).
    * arch/arm/src/lm/lm_gpio.c, lm_gpio.h, and chip/lm4f_pinconfig.h
      Extend GPIO logic to handle LM4F.  Add LM4F pin configuration header
      file (2013-03-04).
    * configs/open1788:  Enable LED support in all configurations.
      (2013-03-04)
    * configs/open1788/nsh:  NSH configuration verified function.  By Rommel
      Marcelo (2013-03-05).
    * configs/open1788/src/lpc17_nsh.c:  Use the SD card interface, not SPI
      to interface with SD cards (2013-03-05.
    * arch/arm/src/lpc17xx/lpc17_sdcard.c and header files:  Clone the STM32
      SD card interface to the LPC1788.  It appears to be the same IP.
      (2013-03-05)
    * libc/wqueue:  Work queue logic moved from sched/ to libc/wqueue.  It
      is not really core OS functionality and this move helps prepare for
      user-space work queues. (2013-03-05)
    * libc/wqueue:  Implemented user-space work queues.  These will not
      get tested until the next time I attempt a NuttX kernel build.
      (2013-03-05).
    * arch/arm: Correct some bad syscall dispatching logic.  This change
      cannot be fully tested until there is a fielded NuttX kernel build.
      (2013-03-06).
    * net/net_poll.c:  Correct logic that checks if the socket is
      disconnected when the poll is setup.  That is bad logic:  Listen
      sockets, for example, are not connected.  In that case, the purpose of
      the poll is to wait for connection events.  As a result of this,
      poll/select would return immediately with POLLHUP with it was used to
      detect connection events.  This fix for now was to check instead if
      the socket is closed (meaning that it was connected at one time but
      was closed by the remote peer).  That excludes the listen socket which
      was never connected.  This does introduce a new problem, however.  If
      the socket was not closed, but lost the connection through an abnormal
      event, then poll/select will hang.  That needs to be revisited.
      (2013-03-07)
    * fs/fs_select.c:  Was not checking if the timeout parameter was NULL
      but would, instead, setup a bogus timeout based on whatever it found at
      address zero.  Also, improved some of the memory allocation logic so
      that it will not use so much memory. (2013-03-07)
    * net/net_poll.c:  Handle the missing case.  Now tests for not connected
      AND not listening.  I think that now covers all of the cases including
      the missing case noted above. (2013-03-07)
    * mm/:  Move all memory manager globals into a structure.  A reference
      to this structure is now passed internally between mm APIs. This
      change will (eventually) support multiple heaps and heap allocators.
      (2013-03-08).
    * mm/ and include/nuttx/mm.h:  Implement support for multiple heaps.
      (2013-03-08).
    * arch/*/src: xyz_addregion() needs to call kmm_addregion, not mm_addregion.
      (2013-03-08).
    * sched/kmm*.c:  Move this garbage kmm*.c file to mm/. until I decide what
      to do with them (which is probably to just delete them). (2013-03-08).
    * mm/mm_test.c and Makefile.test:  Deleted the memory test.  This was
      a good test and helped me a lot when I wrote the memory manager, but
      now it is in the way and paralyzing other efforts.  So the memory unit
      test was deleted. (2013-03-08)
    * sched/sched_free.c:  Rename sched_free() to sched_ufree(); Add
      sched_kfree() to handler deferred kernel heap allocations. (2013-03-10)
    * arch/:  User user-accessible heap to allocate all stacks. (2013-03-10)
    * arch/arm/src/sam3u:  The AT91SAM3U will now support a kernel heap if
      so configured. (2013-03-10)
    * configs/sam3u-ek/knsh:  This configuration was converted to use the
      kconfigs-frontends build tool. (2013-03-10)
    * configs/*/include/user_map.h and include/nuttx/userspace.h:  Remove
      the very kludgy user_map.h file and replace it with a header that
      is expected at the beginning of the user-space blob. (2013-03-10)
    * configs/sam3u-ek/kernel/up_userspace.c:  This is the header for
      the SAM3U-EK's user space.  (2013-03-10)
    * sched/os_bringup.c:  In the kernel build, os_bringup() now uses the
      user-space header to automatically start the user-space work queue,
      if so configured. (2013-03-10)
    * arch/arm/src/lpc17xx/lpc17_mpuinit.c and lpc17_userpace.c:  Add
      support for the MPU and kernel build for the LPC17xx family.
      (2013-03-11)
    * configs/open1788/kernel and knsh:  Add kernel build support and
      a kernel NSH configuration for the WaveShare Open1788 board.
      (2013-03-11)
    * configs/sam3u_ek/kernel, knsh, and scripts:  Move some files around
      for better supportability. (2013-03-11)
    * configs/open1788/kernel, knsh, and scripts:  Add a kernel mode build
      configuration for the WaveShare Open1788 board. (2013-03-11)
    * arch/arm/src/armv7-m/up_mpu.c:  Several fixes to MPU logic.
      (2013-03-12).
    * arch/arm, configs/sam3u-ek, configs/open1788:  Fix memory map for
      kernel mode build; Some regions were overlapping. (2013-03-13).
    * arch/:  Rename g_heapbase to g_idle_topstack.  This is the same value
      however:  The top of the IDLE stack is the same as the base of the
      heap in the flat build.  But not in the kernel build:  The base of
      the heap is elsewhere so the naming was wrong. (2013-03-13).
    * libc/stdlib/lib_itoa.c:  Implementation of itoa() contributed by
      Ryan Sundberg. (2013-03-14).

apps-6.26 2013-03-15 Gregory Nutt &lt;gnutt@nuttx.org&gt;

    * apps/builtin/exec_builtin.c:  Now uses task_spawn() to start
      builtin applications.
    * Type of argv has changed from const char ** to char * const *
    * apps/nshlib/nsh_parse.c:  Fix memory lead: Need to detach after
      creating a pthread.
    * apps/examples and nshlib:  Change name of _TCB to struct tcb_s to
      match NuttX name change.
    * apps/examples/ostest/restart.c:  Add a test case to verify
      task_restart().
    * apps/system/readline.c:  readline() now returns EOF on any failure
      (instead of a negated errno value).  This is because the underlying
      read is based on logic similar to getc.  The value zero was being
      confused with a NUL.  So if a NUL was received, the NSH session
      would terminate because it thought it was the end of file.

NxWidgets-1.6 2013-03-15 Gregory Nutt &lt;gnutt@nuttx.org&gt;

    * Type of argv[] has changed from const char ** to char * const *
    * NXWidgets::CNxWidget:  Add an inline function to get the current style.
    * NxWM::CTaskBar: Make a some methods of CTaskbar virtual to allow
      customizations.  From Petteri Aimonen.
    * NXWidgets::CCycleButton: Make CCycleButton change state in onPreRelease().
      This way the new value is already available when a listener gets the
      action event.  From Petteri Aimonen.
    * NxWidgets/tools/bitmap_converter.py: Fix bitmap_converter.py so that
      it works with indexed input images.
    * NxWidgets::CLabel: Fix backward conditional compilation in the
      &quot;flicker free&quot; logic.
    * NxWidgets::CNxTimer:  Previously repeated timers were re-enabled after
      the timer action event. Consequently, if the action event handler tried
      to stop the timer, the request would be ignored.  Changes the order
      so that the timer is re-enabled before the callback.  There is still
      no risk of re-entrancy, because everything executes on the USRWORK work
      queue.  From Petteri Aimonen.
    * NxWidgets::CMultiLineTestBox: Fix text placement error.  From Petteri
      Aimonen.
    * NxWidgets::CWidgetControl:  Added another semaphore, boundssem, which
      is set as soon as the screen bounds are known.  This corrects two
      problems:
      1) Due to the way nxgl_rectsize computes the size, it will never
         be 0,0 like CWidgetControl expects. Therefore the size is considered
         valid even though it has not been set yet.
      2) After the check is fixed to test for &gt; 1, NxWM window creation will
         hang. This is due to the fact that it uses the screen bounds for
         determining window size. This was being blocked on geosem, which
         is only posted after the size has been set.
      From Petteri Aimonen.
    * NxWidgets::CImage:  Two enhancements:
      1) Allow changing the bitmap even after the control has been created.
      2) Allow giving 'null' to have the control draw no image at all.
      From Petteri Aimonen.
    * NxWM::CTaskBar:  Allow windows with null icon. This makes sense for e.g.
      full screen windows.  From Petteri Aimonen.
    * NxWM::CApplicationWindow:  Add config options to override NxWM
      stop/minimize icons.  From Petteri Aimonen.
    * NwWM::CStartWindow, NxWM::CWindowMessenger: Get rid of the start window
      thread. Instead, handle all events through the USRWORK work queue.
      For me, this was necessary because I would open some files in button
      handlers and close them in NxTimer handlers. If these belonged to
      different tasks, the close operation would fail.  Further benefits:
      + Gets rid of one task and message queue.
      + Reduces the amount of code required
      + Decouples CStartWindow from everything else - now it is just a window
        with application icons, not an integral part of the event logic.
      + All events come from the same thread, which reduces the possibility of
        multithreading errors in user code.
      + The user code can also send events to USRWORK, so that everything gets
        serialized nicely without having to use so many mutexes.
      Drawbacks:
      - Currently the work state structure is malloc()ed, causing one allocation
        and free per each input event. Could add a memory pool for these later, but
        the speed difference doesn't seem noticeable.
      - The work queue will add ~50 ms latency to input events. This is however
        configurable, and the delay is anyway short enough that it is unnoticeable.
      From Petteri Aimonen.

uClibc++-1.0 2011-11-05 &lt;gnutt@nuttx.org&gt;

    * The initial release of the uClibc++ implementation of the standard
      C++ library for NuttX.  This package was contributed ay Qiang Yu and
      David for the RGMP team.

buildroot-1.12 2011-13-15 &lt;gnutt@nuttx.org&gt;

    * Fix typo toolchain/gdb/Config.in that prevented GDB 7.4 from building
      (from Ken Bannister).
    * Add support for a Cortex-M0 toolchain based on GCC 4.6.3.

pascal-3.0 2011-05-15 Gregory Nutt &lt;gnutt@nuttx.org&gt;

    * nuttx/:  The Pascal add-on module now installs and builds under the
      apps/interpreters directory.  This means that the pascal-2.1 module is
      incompatible with will all releases of NuttX prior to nuttx-6.0 where the 
      apps/ module was introduced.
</pre></ul>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="pendingchanges">Unreleased Changes</a>
  </td>
  </tr>
</table>

<ul>
  <li><b>nuttx</b>.
    The ChangeLog for the not-yet-released version of NuttX is available at the bottom of the ChangeLog file that can viewed in the <a href="http://sourceforge.net/p/nuttx/git/ci/master/tree/nuttx/ChangeLog">SourceForge GIT</a>.
  </li>
  <li><b>apps</b>.
    The ChangeLog for the not-yet-released version of apps is available at the bottom of the ChangeLog file that can viewed in the <a href="http://sourceforge.net/p/nuttx/git/ci/master/tree/apps/ChangeLog.txt">SourceForge GIT</a>.
  </li>
  <li><b>NxWidgets</b>.
    The ChangeLog for the not-yet-released version of NxWidgets is available at the bottom of the ChangeLog file that can viewed in the <a href="http://sourceforge.net/p/nuttx/git/ci/master/tree/NxWidgets/ChangeLog">SourceForge GIT</a>.
  </li>
  <li><b>pascal</b>.
    The ChangeLog for the not-yet-released version of pascal is available at the bottom of the ChangeLog file that can viewed in the <a href="http://sourceforge.net/p/nuttx/git/ci/master/tree/misc/pascal/ChangeLog">SourceForge GIT</a>.
  </li>
  <li><b>buildroot</b>.
    The ChangeLog for the not-yet-released version of buildroot is available at the bottom of the ChangeLog file that can viewed in the <a href="http://sourceforge.net/p/nuttx/git/ci/master/tree/misc/buildroot/ChangeLog">SourceForge GIT</a>.
  </li>
</ul>

<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="TODO"><h1>Bugs, Issues, <i>Things-To-Do</i></h1></a>
  </td>
  </tr>
</table>

<ul>
<p>
   The current list of NuttX <i>Things-To-Do</i> in GIT <a href="http://sourceforge.net/p/nuttx/git/ci/master/tree/nuttx/TODO">here</a>.
   A snapshot of the <i>To-Do</i> list associated with the current release are available <a href="TODO.txt">here</a>.
</p>
</ul>
<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="documentation"><h1>Other Documentation</h1></a>
  </td>
  </tr>
</table>

<ul><table>
<tr>
  <td valign="top" width="22"><img height="20" width="20" src="favicon.ico"></td>
  <td><a href="NuttXGettingStarted.html">Getting Started</a></td>
</tr>
<tr>
  <td valign="top" width="22"><img height="20" width="20" src="favicon.ico"></td>
  <td><a href="NuttxUserGuide.html">User Guide</a></td>
</tr>
<tr>
  <td valign="top" width="22"><img height="20" width="20" src="favicon.ico"></td>
  <td><a href="NuttxPortingGuide.html">Porting Guide</a></td>
</tr>
<tr>
  <td valign="top" width="22"><img height="20" width="20" src="favicon.ico"></td>
  <td><a href="NuttShell.html">NuttShell (NSH)</a></td>
</tr>
<tr>
  <td valign="top" width="22"><img height="20" width="20" src="favicon.ico"></td>
  <td><a href="NuttXBinfmt.html">NuttX Binary Loader</a></td>
</tr>
<tr>
  <td valign="top" width="22"><img height="20" width="20" src="favicon.ico"></td>
  <td><a href="NuttXNxFlat.html">NXFLAT Binary Format</a></td>
</tr>
<tr>
  <td valign="top" width="22"><img height="20" width="20" src="favicon.ico"></td>
  <td><a href="NXGraphicsSubsystem.html">NX Graphics Subsystem</a></td>
</tr>
<tr>
  <td valign="top" width="22"><img height="20" width="20" src="favicon.ico"></td>
  <td><a href="NxWidgets.html">NxWidgets</a></td>
</tr>
<tr>
  <td valign="top" width="22"><img height="20" width="20" src="favicon.ico"></td>
  <td><a href="NuttXDemandPaging.html">Demand Paging</a></td>
</tr>
<tr>
  <td valign="top" width="22"><img height="20" width="20" src="favicon.ico"></td>
  <td><a href="README.html">NuttX README Files</a></td>
</tr>
<tr>
  <td valign="top" width="22"><img height="20" width="20" src="favicon.ico"></td>
  <td><a href="ChangeLog.txt">Change Log</a></td>
</tr>
<tr>
  <td valign="top" width="22"><img height="20" width="20" src="favicon.ico"></td>
  <td><a href="TODO.txt">To-Do List</a></td>
</tr>
<tr>
  <td valign="top" width="22"><img height="20" width="20" src="favicon.ico"></td>
  <td><a href="UsbTrace.html">USB Device Driver Tracing</a></td>
</tr>
</center></ul>

<small>
<table width ="100%">
  <tr bgcolor="#e4e4e4">
  <td>
    <a name="trademarks"><h1>Trademarks</h1></a>
  </td>
  </tr>
</table>
<ul>
  <li>ARM, ARM7 ARM7TDMI, ARM9, ARM920T, ARM926EJS Cortex-M3 are trademarks of Advanced RISC Machines, Limited.</li>
  <li>Cygwin is a trademark of Red Hat, Incorporated.</li>
  <li>Linux is a registered trademark of Linus Torvalds.</li>
  <li>Eagle-100 is a trademark of <a href=" http://www.micromint.com/">Micromint USA, LLC</a>.
  <li>LPC2148 is a trademark of NXP Semiconductors.</li>
  <li>TI is a tradename of Texas Instruments Incorporated.</li>
  <li>UNIX is a registered trademark of The Open Group.</li>
  <li>VxWorks is a registered trademark of Wind River Systems, Incorporated.</li>
  <li>ZDS, ZNEO, Z16F, Z80, and Zilog are a registered trademark of Zilog, Inc.</li>
</ul>
<p>
  NOTE: NuttX is <i>not</i> licensed to use the POSIX trademark.  NuttX uses the POSIX
  standard as a development guideline only.
</p>
</small>

</body>
</html>

